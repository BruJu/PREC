<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PREC</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "unofficial",
        editors: [
            {
                name: "Julian Bruyat",
                url: "https://bruy.at",
                company: "LIRIS - INSA Lyon",
                companyURL: "https://liris.cnrs.fr",
                mailto: "julian.bruyat@insa-lyon.fr"
            }
        ],
        github: "https://github.com/BruJu/PREC/",
        xref: "web-platform",
        format: "markdown"
      };
    </script>
  </head>
  <body>
    <h2 id="subtitle">Property Graph - RDF Experimental Converter</h2>
    <section id="abstract">
      <p>PREC is a library designed to enable interoperability between RDF graphs
        and property graphs.</p>

      <p>This document mainly describes the PREC ontology: an ontology designed
        to describes the binding between the terms used in an RDF graph and the
        labels used in a property graph.</p>
    </section>
    <section>
      <h2>Introduction</h2>

      <p><a href="https://github.com/BruJu/PREC/">PREC</a> is composed of two modules:</p>
      <ul>
        <li><dfn>PREC-0</dfn>, a Property Graph to RDF graph converter</li>
        <li><dfn>PREC-Context</dfn>, an RDF Graph generated from PREC-0 to more readable graphs converter</li>
      </ul>
      
      <p>To define the transformations to apply, PREC-Context uses a <em>Context</em> provided
      by the user in <a href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html#turtle-star">Turtle-Star</a> format.
      </p>

      <aside class="warning" title="(Un)stability of the ontology">
        <p>This ontology is currently very tentative and is subject to change.</p>
      </aside>

      <section>
        <h3>Schema of the PREC-0 graphs</h3>
        <p>TODO</p>
      </section>

      <section>
        <h3>Use of a context</h3>

        <p>The context can be automatically applied during the convertion of the Property Graph to RDF:</p>
        <ul>
          <li>For example, for a Neo4j graph for which you have already extacted
            the content in Json format, use
            `node prec.js path_to_property_graph_content.json path_to_context.ttl`
          </li>
        </ul>
      
        <p>If you have already generated the PREC-0 graph, you can use the ApplyContext tool:</p>
        <ul>
          <li>`node tools.js ApplyContext path_to_prec0_graph.ttl path_to_context.ttl`</li>
        </ul>

      </section>

      <section>
        <h3>Example of a context</h3>

        <p>TODO</p>
      </section>
    </section>

    <section>
      <h2>The PREC ontology</h2>

      <section>
        <h3>Types</h3>

        <section>
          <h4>http://bruy.at/prec#CreatedVocabulary</h4>
          
          <p>Type of IRIs that has been created by PREC and that
          should be mapped to an actual ontology.</p>

          <p>It only applies to labels and property names.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#Property</h4>

          <p>Type of property keys / labels.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#PropertyValue</h4>

          <p>Type of property values. Can be seed as the counterpart of
          <a href="http://ii.uwb.edu.pl/pgo#Property">pgo:Property</a> in the
          PREC modelization.</p>
        </section>
        
        <section>
          <h4>http://bruy.at/prec#hasMetaProperties</h4>

          <p>States to which (RDF) node the meta properties of a property are
            attached to.</p>

            <aside class="example">
              <p>Bob lives in Paris and is a tenant of his appartment.</p>
              <pre class="ttl">
                _:bob :live_in [
                    rdf:type prec:PropertyValue ;
                    rdf:value "Paris" ;
                    prec:hasMetaProperties [
                        :status [ rdf:value "Tenant" ; rdf:type prec:PropertyValue ]
                    ]
                ] .
                
                :live_in a prec:Property .
                :status  a prec:Property .
              </pre>
            </aside>
        </section>
      </section>

      
      <section>
        <h3>Reserved IRIs</h4>

        <p>IRIs in the `prec` namespace are reserved for the ontology (obviously).</p>

        <p><a href="https://github.com/BruJu/PREC/">The default implementation</a>
          reserves for itself the IRIs prefixed with `_` and `__`.  Therefore,
          as they are reserved for implementation, using them in a context
          results in undefined behaviour.</p>
      </section>

      <section>
        <h3>General directives</h3>

        <section>
          <h4><dfn data-lt="prec:KeepProvenance">http://bruy.at/prec#KeepProvenance</dfn></h4>

          <p>By default, a triple is created for each node / relationship /
            property / property value between its IRI / blank node and the type.
          <br>If this flag is set to `false`, the triples in the form
            `ex:node1 a pgo:Node` are deleted from the output graph.</p>

          <aside class="example">
            <p>Keep the types (default behaviour).</p>
            <pre class="ttl">
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState true .
            </pre>

            <p>Remove the types.</p>
            <pre class="ttl">
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState false .
            </pre>
          </aside>
        </section>

        <section>
          <h4>http://bruy.at/prec#flagState</h4>

          <p>Used as the predicate of [= prec:KeepProvenance =].</p>
        </section>
      </section>

      <section>
        <h3>Change the schema of the generated graph</h3>

        <p>[= PREC-0 =] generates an RDF Graph with a certain format. It is
          possible to change the way the properties and the relationships are
          modelled in the RDF graph.</p>

        <p>By default:</p>
        <ul>
          <li>Relationships are materialized using a standard RDF Reification</li>
          <pre>
            _:theEdge a pgo:Edge ;
              rdf:subject _:sourceNode ;
              rdf:predicate [ rdfs:label "TheLabel" ] ;
              rdf:object _:targetNode .
          </pre>
          <li>Properties are materialized like in the following example:</li>
          <pre>
            _:eitherTheNodeOrTheEdge :propertyKey _:aBlankNode .
            _:aBlankNode rdf:value "The value of the property" .
            _:aBlankNode prec:hasMetaProperties _:aNodeWithTheMetaPropertiesIfAny .
            
            :propertyKey a prec:Property ; rdfs:label "The name of the property" .
            _:aBlankNode a prec:PropertyValue .
          </pre>
        </ul>

        <p>[= PREC-Context =] is able to change the format used to represent the
          properties and the relationships by using models.
          <br>In PREC, we call a *model* the format wanted by the user.</p>

          <section>
            <h4><dfn data-lt="prec:modelAs">http://bruy.at/prec#modelAs</dfn></h4>

            <p>Predicate used to state that the subject must be modelled in the
              format described in the object.</p>

              <aside class="example">
                <p>A context that requires every relationship to be modelled
                  with the Singleton Property pattern.</p>
                <pre class="ttl">
                  PREFIX prec: <http://bruy.at/prec#>
                  prec:Relationships prec:modelAs prec:SingletonProperty .
                </pre>
              </aside>

          </section>

        <section>
          <h4>Relationship models</h4>

          <p>[= PREC-Context =] uses a special IRI for the set of every
            relationships and defines some base models that are implcitely
            defined in every context.</p>

          <p>Thanks to these IRIs and [= prec:modelAs =], it is possible to
            tranform the model used for every relationship from the standard
            RDF Reification to any model.
          </p>
          
          <section>
            <h5><dfn data-lt="prec:Relationships">http://bruy.at/prec#Relationships</dfn></h5>

            <p>[= prec:Relationships =] is the domain of every relationship. A
              model that is applied to this IRI will be applied to every
              relationship.</p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RDFReification">http://bruy.at/prec#RDFReification</dfn></h5>
            <p>`prec:Relationships prec:modelAs prec:RDFReification .`
              <br>Relationships must be modeled as a standard RDF Reification.
              This is the default behaviour.</p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarUnique">http://bruy.at/prec#RdfStarUnique</dfn></h5>
            <p>`prec:Relationships prec:modelAs prec:RdfStarUnique .`
              <br>Relationships are modeled as a triple that is added to th
               graph, and meta properties are added using RDF-star. This model
               will cause information loss if there are two edges with the same
               label between two nodes.</p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarOccurrence">http://bruy.at/prec#RDFStarOccurrence</dfn></h5>
            <p>`prec:Relationships prec:modelAs prec:RDFStarOccurrence .`
              <br>Relationships are modeled as an RDF-star occurence: a blank
              node represents the occurrence and [= prec:occurrenceOf =] is used
              to link the node to the triple it is an occurence of.
            </p>

            <section>
              <h5><dfn data-lt="prec:occurrenceOf">http://bruy.at/prec#occurrenceOf</dfn></h5>

              <p><em>
                This IRI is used in the generated graphs and should not be used
                in contexts as a "keyword".
              </em></p>

              <p>
                Specifies for which triple the relationship is an occurrenceOf.
              </p>

              <aside class="example">
                <p>
                  Joe Biden "worked" for the White House from 2009 to 2017 as
                  the vice president and since 2021 as the president.
                </p>
                

                <pre class="ttl">
                  _:first  prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  _:second prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  
                  _:first  :from 2009; :to 2017 ; :role "Vice President" .
                  _:second :from 2021;            :role "President"      .
                </pre>

                <p><em>Why do we need this?</em></p>
                
                <p>If we write</p>

                <pre>
                << :joe_biden :workingFor :white_house >> :from 2009; :to 2017 ; :role "Vice President" .
                << :joe_biden :workingFor :white_house >> :from 2021;            :role "President"      .
                </pre>
                
                it is equivalent to writing
                <pre>
                << :joe_biden :workingFor :white_house >>
                    :from 2009, 2021 ;
                    :to 2017 ;
                    :role "Vice President", "President" .
                </pre>
                
                <p>
                  While we can deduce from the semantic of `:from`, `:to` and
                  years that Joe Biden worked from 2009 to 2017 then from 2021
                  for the White House, and while we know that we worked as the
                  Vice President and the President, we are unable to distinguish
                  when he was Vice President and when he was President.
                </p>
              </aside>
            </section>
          </section>
          <section>
            <h5><dfn data-lt="prec:SingletonProperty">http://bruy.at/prec#SingletonProperty</dfn></h5>
            <p>`prec:Relationships prec:modelAs prec:SingletonProperty .`
              <br>Relationships must be modeled using singleton properties.</p>
          </section>
        </section>

        <section>
          <h4>Property models</h4>

          <p>The model used for properties can also be redefined.</p>

          <section>
            <h5><dfn data-lt="prec:Properties">http://bruy.at/prec#Properties</dfn></h5>

            <p>
              The domain of every properties. A triple that has
              [= prec:Properties =] as a subject is equivalent to two triples,
              one with [= prec:NodeProperties =] as the subject and another with
              [= prec:RElationshipProperties =] as the subject.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:NodeProperties">http://bruy.at/prec#NodeProperties</dfn></h5>

            <p>The domain of every node properties. The properties on
              relationships won't be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RelationshipProperties">http://bruy.at/prec#RelationshipProperties</dfn></h5>

            <p>The domain of every relationship properties. The properties on
              nodes won't be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:Prec0Property">http://bruy.at/prec#Prec0Property</dfn></h5>

            <p>
              Properties are modeled in the format presented in the
              [= prec:hasMetaProperties =] example. This is the default
              behaviour.
            </p>

            <aside class="warning">
              <p><em>This mode may not be the default behaviour in the future.</em></p>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:CombinedBlankNodes">http://bruy.at/prec#CombinedBlankNodes</dfn></h5>

            <p>
              Properties are modeled in the same format as
              [= prec:Prec0Property =], but the `propertyValue` and the
              `metaProperty` nodes are merged.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:DirectTriples">http://bruy.at/prec#DirectTriples</dfn></h5>

            <p>
              Properties are modeled without any blank node
              (`:node :propertyKey :thePropertyValueLiteral`), and the meta
              properties are represented by using RDF-star.
            </p>
          </section>
        </section>

        <section>
          <h4>Writting your own models</h4>

          <p>
            So far, this document described how to use predefined models. It is
            also possible to write you own models.
          </p>

          <p>
            Models uses the `pvar` namespace (http://bruy.at/prec-trans#) as
            variable. pvar can be seen as a way to write `?` in a Turtle file
            without actually using a real variable.
          </p>

          <section>
            <h5><dfn data-lt="prec:composedOf">http://bruy.at/prec#composedOf</dfn></h5>

            <p>
              Used to state the list of RDF triples that composes the model.
              When the model is applied, every triple used in the default PREC0
              model will be replaced with the triples that composes the model.
            </p>

            <p>
              Models and the variables it contains can be seen as a template.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeTransformation">http://bruy.at/prec#EdgeTransformation</dfn></h5>

            <aside class="warning">
              TODO: EdgeTransformation should be named RelationshipModel
            </aside>

            <p>The type of models that can be used for relationships.</p>

            <p>`EdgeTransformation`s use the following variable:</p>
            <ul>
              <li>`pvar:self`: The RDF node that was created to identify the relationship.</li>
              <li>`pvar:source`: The RDF node that represents the PG source node of the relationship.</li>
              <li>`pvar:destination`: The RDF node that represents the PG destination relationship.</li>
              <li>`pvar:relationshipIRI`: The RDF node that represents the label of the edge.</li>
              <li>`pvar:propertyKey`: matchs every other predicates. Supposed to represent each property key.</li>
              <li>`pvar:propertyValue`: matchs every other objects. Supposed to represent each property value.</li>
            </ul>

            <p>
              We are going to show how an user can define its own model

            <aside class="example">
              <p>An [= prec:EdgeTransformation =] that is the identity / the standard RDF Reification</p>
              <pre class="ttl">
                prec:RDFReification a prec:EdgeTransformation ;
                  prec:composedOf
                    << pvar:self a pgo:Edge >> ,
                    << pvar:self rdf:subject      pvar:source          >> ,
                    << pvar:self rdf:predicate    pvar:relationshipIRI >> ,
                    << pvar:self rdf:object       pvar:destination     >> ,
                    << pvar:self pvar:propertyKey pvar:propertyValue   >>
                .
              </pre>

              <p>
                Note that `prec:RDFReification` is the pattern that is matched
                against, which means modelling a relationship as a
                `prec:RDFReification` will result in the samegraph.
              </p>
            </aside>

            <aside class="example">
              <p>
                [= prec:RDFStarUnique =] is a model that assumes that every
                edges between the same two nodes have a different label.
              </p>
              <pre class="ttl">
                prec:RdfStarUnique a prec:EdgeTransformation ;
                  prec:composedOf
                    <<    pvar:source pvar:relationshipIRI pvar:destination               >> , # (a)
                    << << pvar:source pvar:relationshipIRI pvar:destination >> a pgo:Edge >> , # (b)
                    << << pvar:source pvar:relationshipIRI pvar:destination >> pvar:propertyKey pvar:propertyValue >>  # (c)
                .
              </pre>

              <p>If we suppose we have the following RDF Graph:</p>
              
              <pre>
              _:edge1 a pgo:Edge ;
                      rdf:subject _:src ;
                      rdf:predicate _:label ;
                      rdf:object _:dest ;
                      _:propPlace _:propValuePlace ;
                      _:propTime  _:propValueTime .
              </pre>

              <p>The variables will match as follow:</p>

              <table>
                <tr><th>Variable name</th>             <th>Value</th>               </tr>
                <tr><td> `pvar:self`              </td><td> `_:edge1`          </td></tr>
                <tr><td> `pvar:source`            </td><td> `_:src`            </td></tr>
                <tr><td> `pvar:destination`       </td><td> `_:dest`           </td></tr>
                <tr><td> `pvar:relationshipIRI`   </td><td> `_:label`          </td></tr>
                <tr><td> `pvar:propertyKey`   (1) </td><td> `_:propPlace`      </td></tr>
                <tr><td> `pvar:propertyValue` (2) </td><td> `_:propValuePlace` </td></tr>
                <tr><td> `pvar:propertyKey`   (2) </td><td> `_:propTime`       </td></tr>
                <tr><td> `pvar:propertyValue` (2) </td><td> `_:propValueTime`  </td></tr>

              </table>
              

              <p>And the produced graph will be the following:</p>
              <pre>
                _:src _:label _:dest .                  # From (a)
                << _:src _:label _:dest >> a pgo:Edge . # From (b)
                << _:src _:label _:dest >> _:propPlace _:propValuePlace . # From (c) using (1) bindings
                << _:src _:label _:dest >> _:propTime  _:propValueTime  . # From (c) using (2) bindings
              </pre>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:PropertyTransformation">http://bruy.at/prec#PropertyTransformation</dfn></h5>

            <p>The type of models that can be used for properties.</p>
            
            <aside class="warning">
              <p>TODO: PropertyTransformation should be named PropertyModel</p>
            </aside>
            
            <aside class="warning">
              <p>Meta properties are not yet supported.</p>
            </aside>

            <p>`prec:PropertyTransformation`s use the following variables:</p>
            <ul>
              <li>`pvar:entity`: The RDF node that was created to identify the edge of the node.</li>
              <li>`pvar:propertyKey`: The node that represents the edge label.</li>
              <li>`pvar:property`: The blank node that represents the property.</li>
              <li>`pvar:propertyValue`: The literal that contains the property value.</li>
            </ul>

            <p>
              The substitution mecanism is the same as described in the
              [= prec:EdgeTransformation =] section.
            </p>
          </section>


        </section>

      <section>
        <h3>Rules</h3>

        <p>
          Rules are the main way to modify a [= PREC-0 =] RDF graph. They let
          the user modify specific elements of the graphs by:
          <ul>
            <li>filtering some of the relationships or properties</li>
            <li>applying a specific model to these entities</li>
          </ul>
        </p>

        <p>
          As one can expect, there are two different kind of rules : rules for
          relationships ([= prec:RelationshipRule =]) and rules for properties
          ([= prec:PropertyRule =]).
        </p>

        <section>
          <h4>Relationship rules</h4>

          <p>
            Relationship rules aim to modify the way the property graph
            relationships are materialized in the RDF Graph.
          </p>

          <aside class="example">
            <p>
              A rule that only applies to relationships with the label "Like"
              and for which both the source and the destination node have the
              label "Person". This rule will materialize these relationship
              as a standard RDF Triple, with `ex:like` as the predicate
              (for example `:alice ex:like :bob` will be produced).
            </p>

            <pre>
              [] a prec:RelationshipRule ;
                # - Filtering
                # Like must be the relationship label
                prec:relationshipLabel "Like" ;
                # The source node must have the label Person
                prec:sourceLabel      "Person" ;
                # The destination node must have the label Person
                prec:destinationLabel "Person" ;
                # - Transformation
                # Replace the generated IRI for the relationship label with ex:like
                prec:relationshipIRI ex:like ;
                # Modelize this relationship by using the prec:RDFStarUnique
                # model instead of a standard RDF Reification
                prec:modelAs prec:RDFStarUnique .
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:RelationshipRule">http://bruy.at/prec#RelationshipRule</dfn></h5>

            <p>
              The type of relationship rules. The [= PREC-Context =] engine
              currently requires the relationship rules to be properly typed to
              discover them.
            </p>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:relationshipLabel">http://bruy.at/prec#relationshipLabel</dfn></h5>

            <p>
              States that the relationship must have the given label to match
              the rule. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:relationshipIRI">http://bruy.at/prec#relationshipIRI</dfn></h5>

            <p>
              States that the generated node for the relationship must be
              replaced with the given IRI.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:sourceLabel">http://bruy.at/prec#sourceLabel</dfn></h5>

            <p>
              States that the relationship source node must have the given
              label. The value must be a literal.
            </p>

            
            <aside class="example">
              <p>
                Let us consider we have the following property graph, with
                three nodes: one of type Person, one of type Cat and one of type
                Food. The Person likes the Cat and the Cat likes the Food.
              </p>

              <pre>
                               (a)                    (b)
              [ :Person ] --- :Like --> [ :Cat ] --- :Like --> [ :Food ]
              </pre>

              <p>
                We can write the following relationship rule:
              </p>

              <pre>
                prec:Relationships prec:modelAs prec:RDFStarUnique .

                # Matches (a)
                :firstRule a prec:RelationshipRule ;
                  prec:relationshipLabel "Like" ;
                  prec:sourceLabel "Person" ;
                  prec:relationshipIRI ex:likes .
                
                # Matches (b)
                :secondRule a prec:RelationshipRule ;
                  prec:relationshipLabel "Like" ;
                  prec:sourceLabel "Cat" ;
                  prec:relationshipIRI ex:eats .
              </pre>

              <p>The output graph would be the following:</p>

              <pre>
                # Matches :firstRule, also applies the new default model
                _:person ex:likes _:cat  {| a pgo:Edge |} .
                # Matches :secondRule, also applies the new default model
                _:cat    ex:eats  _:food {| a pgo:Edge |} .

                _:person a pgo:Node, [ rdfs:label "Person" ].
                _:cat    a pgo:Node, [ rdfs:label "Cat"    ].
                _:food   a pgo:Node, [ rdfs:label "Food"   ].
              </pre>
            </aside>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:destinationLabel">http://bruy.at/prec#destinationLabel</dfn></h5>

            <p>
              Same as [= prec:sourceLabel =], but for the destination node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfRelationship">http://bruy.at/prec#IRIOfRelationship</dfn></h5>

            <p>
              Shortcut to define a relationship rule that matches relationships
              with a specific label and map the relationship label to a specific
              IRI.
            </p>

            <p>The two following contexts are equivalents:

              <pre>
                :iri prec:IRIOfRelationship "Label" .
              </pre>
              <pre>
                [] a prec:RelationshipRule ;
                  prec:relationshipLabel "Label" ;
                  prec:relationshipIRI :iri .
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifiying a model</h5>

            <p>
              Like [= prec:Relationships =], it is possible to define a target
              model for relationship rules by using the [= prec:modelAs =]
              predicate. It is also possible to apply any
              [= prec:SubstitutionTerm =]s, and not only
              [= prec:relationshipIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4>Property rules</h4>

          <p>
            A property rule is a rule that can be applied to a property. In a
            similar fashion as relationship rules, a property rule targets some
            properties, and can modify how they are materialized in the graph.
          </p>



          TODO



        </section>

        <section>
          <h4><dfn data-lt="prec:priority">http://bruy.at/prec#priority</dfn></h4>

          <p>
            By default, [= PREC-Context =] tries to apply rules from the more
            specific to the less specific. While the order of the rules is
            deterministic, the user may prefer to use another.
            [= prec:priority =] enables to change the order of the rules.
          </p>

          <aside class="example">
            <p>
              With this context, thanks to the priority, if a relationship
              has a source label that is both an animal and a person, the
              `:personLike` rule is guaranteed to be applied.
            </p>
            <pre>
              :personLike a prec:RelationshipRule ;
                prec:relationshipLabel "Like" ;
                prec:sourceLabel "Person" ;
                prec:priority 2 ;
                prec:relationshipIRI ex:likes .
                
              :catLike a prec:RelationshipRule ;
                prec:relationshipLabel "Like" ;
                prec:sourceLabel "Animal" ;
                prec:priority 1 ;
                prec:relationshipIRI ex:kind_of_accepts .
            </pre>
          </aside>
        </section>

        <section>
          <h4><dfn data-lt="prec:IRIOfNodeLabel">http://bruy.at/prec#IRIOfNodeLabel</dfn></h4>

          <p><em>Usage</em>: ` :IRIToMapTo prec:IRIOfNodeLabel "Label" .`</p>

          <p>
            The last kind of nodes that can be remapped are node labels. Unlike
            property labels, the only way to map an IRI to them is to use
            the [= prec:IRIOfNodeLabel =], in a similar fashion as
            [= prec:IRIOfRelationship =].
          </p>

          <p>
            [= prec:IRIOfNodeLabel =] states that the node labels equals to
            its object (`"Label`) should be mapped to the IRI stated as the
            subject of the triple (`:IRIToMapTo`), instead of generating /
            keeping a generated a blank node or IRI.
          </p>

          <aside class="example">
            <p>Let us consider the following property graph with two nodes, one
              with the label Person and one with the label Animal:
            </p>
            
            <pre>
            [ :Person ]    [ :Animal ]
            </pre>

            <p>
              [= PREC-0 =] will convert this graph into the following RDF graph:
            </p>

            <pre>
              _:node1 a pgo:Node, [ rdfs:label "Person" ] .
              _:node2 a pgo:Node, [ rdfs:label "Animal" ] .
            </pre>

            <p>Let us consider the following context:</p>

            <pre>
              schema:Person prec:IRIOfNodeLabel "Person" .
              schema:Animal prec:IRIOfNodeLabel "Animal" .
            </pre>

            <p>
              [= PREC-Context =] will transform the [= PREC-0 =] graph into
              the following:
            </p>

            <pre>
              _:node1 a pgo:Node, schema:Person .
              _:node2 a pgo:Node, schema:Animal .
            </pre>
          </aside>
        </section>

        
        <section>
          <h4>Map blank nodes to prefix</h4>

          <p>
            TODO
          </p>

        </section>

      </section>
>
      
      <section>
        <h3>Substitutions</h3>

        <p>
          Most rules actually use alterations of models. For example, in
          [= prec:RelationshipRule =]s, most of the time the
          `pvar:relationshipIRI` variable will be replaced by an IRI picked by
          the user thanks to [= prec:relationshipIRI =].
        </p>

        <p>
          The reason why [= prec:relationshipIRI =] can modify the model is
          because it is defined as a [= prec:SubstitutionTerm =] for
          `pvar:relationshipIRI`: when used in a rule,
          [= prec:relationshipIRI =] will look for every `pvar:relationshipIRI`
          occurrence, and replace it with something else.
        </p>

        <section>
          <h4><dfn data-lt="prec:SubstitutionTerm">http://bruy.at/prec#SubstitutionTerm</dfn></h4>

          <p>
            The type of substitution terms. To be effective, a
            [= prec:SubstitutionTerm =] should have a value for
            [= prec:substitutionTarget =].
          </p>
        </section>

        <section>
          <h4><dfn data-lt="prec:substitutionTarget">http://bruy.at/prec#substitutionTarget</dfn></h4>

          <p>
            States the term that is looked for in the model on which the
            substitution term applies.
          </p>
          
          <aside class="example">
            <p>`prec:subject` is a substitution term for `rdf:subject`.</p>
            <pre class="ttl">
              prec:subject a prec:SubstitutionTerm ;
                prec:substitutionTarget rdf:subject.
            </pre>

            <p>
              When `prec:subject` is used on a rule, it will replace
              `rdf:subject` with something else. Similar directives exist
              for `prec:predicate` and `prec:object`.
            </p>
          </aside>

          <aside class="example">
            <p>
              Let us consider we have the following property graph. Values
              inside parenthesis are not actual values, and are solely for
              clarity. In this graph, we have two nodes, and a relationship
              from one to another with the label `like`.
            </p>

            <pre>
                        (edge):like
              [(alice)] ------------> [(bob)]
            </pre>

            <p>
              [= PREC-0 =] translates this property graph into an RDF graph
              isomorphic to the following:
            </p>

            <pre>
              _:alice a pgo:Node .
              _:bob   a pgo:Node .
              _:edge  a pgo:Edge ;
                rdf:subject _:alice ;
                rdf:predicate [ rdfs:label "like" ] ;
                rdf:object  _: bob .
            </pre>

            <p>
              If we apply the following context with [= PREC-Context =], we will
              obtain the following RDF Data graph:
            </p>

            <pre class="ttl">
              # Context
              prec:Relationships prec:modelAs prec:RDFReificaiton ;
                prec:subject <https://example.org/user> ;
                prec:predicate rdf:type ;
                prec:object <https://example.org/influencer> .
            </pre>

            <pre class="ttl">
              # RDF Data Graph
              _:edge a pgo:Edge ;
                <https://example.org/user> _:alice ;
                rdf:type [ rdfs:label "like" ] ;
                <https://example.org/influencer> _:bob .
              
              _alice a pgo:Node .
              _:bob  a pgo:Node .
            </pre>
          </aside>
        </section>

        <section>
          <h4>Substitution terms defined in every context</h4>

          <p>
            The following substitution terms are defined for every context by
            [= PREC-Context =]:
            <ul>
              <li>`prec:subject`: Substitution term for `rdf:subject`.</li>
              <li>`prec:predicate`: Substitution term for `rdf:predicate`.</li>
              <li>`prec:object`: Substitution term for `rdf:object`.</li>
              <li>`prec:relationshipIRI`: Substitution term for `pvar:relationshipIRI`. Expected to be used in most [= prec:RelationshipRule =]s.</li>
              <li>`prec:propertyIRI`: Substitution term for `pvar:propertyIRI`. Expected to be used in most [= prec:PropertyRule =].</li>
            </ul>
          </p>

          <p>
            `prec:subject`, `prec:predicate`, `prec:object` are defined to
            model a relationship as a fully fledge object. They let the user
            rename more accurate terms than the "RDF grounded terms". This is
            inspired by http://www.bobdc.com/blog/reification-is-a-red-herring/.
          </p>
        </section>
      </section>
    </section>


    <section>
      <h2>A section</h2>
      <aside class="example">
        <p>This is an example.</p>
        <pre class="js">
        // Automatic syntax highlighting
        function someJavaScript(){}
        </pre>
      </aside>
      <section>
        <h3>I'm a sub-section</h3>
        
      </section>
    </section>
    <section data-dfn-for="Foo">
      <h2>Start your spec!</h2>
      <pre class="idl">
        [Exposed=Window]
        interface Foo {
        attribute DOMString bar;
        undefined doTheFoo();
        };
      </pre>
      <p>The <dfn>Foo</dfn> interface represents a {{Foo}}.</p>
      <p>
        The <dfn>doTheFoo()</dfn> method does the foo. Call it by running
        {{Foo/doTheFoo()}}.
      </p>
      <ol class="algorithm">
        <li>A |variable:DOMString| can be declared like this.</li>
      </ol>
    </section>
    <section id="conformance">
      <p>
        This is required for specifications that contain normative material.
      </p>
    </section>
    <section class="appendix">
      <h2>Change log</h2>
      <p>Recent changes to this specification from GitHub:</p>
      <!-- <rs-changelog from="some-git-tag"> </rs-changelog> -->
    </section>
  </body>
</html>
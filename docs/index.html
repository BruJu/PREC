<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PREC</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "unofficial",
        editors: [
            {
                name: "Julian Bruyat",
                url: "https://bruy.at",
                company: "LIRIS - INSA Lyon",
                companyURL: "https://liris.cnrs.fr"
            }
        ],
        github: "https://github.com/BruJu/PREC/",
        xref: "web-platform",
        format: "markdown"
      };
    </script>
    
      <script>
        /* copied from JSON-LD specs */
        function updateExample(doc, content) {
          // perform transformations to make it render and prettier
          return _esc(reindent(unComment(doc, content)));
        }
    
        function _esc(s) {
          return s.replace(/&/g,'&amp;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/</g,'&lt;');
        }
    
        function reindent(text) {
          // TODO: use trimEnd when Edge supports it
          const lines = text.trimRight().split("\n");
          while (lines.length && !lines[0].trim()) {
            lines.shift();
          }
          const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
          const leastIndent = Math.min(...indents);
          return lines.map(s => s.slice(leastIndent)).join("\n");
        }
    
        function unComment(doc, content) {
          // perform transformations to make it render and prettier
          return content
            .replace(/<!--/, '')
            .replace(/-->/, '')
            .replace(/< !\s*-\s*-/g, '<!--')
            .replace(/-\s*- >/g, '-->')
            .replace(/-\s*-\s*&gt;/g, '--&gt;');
        }
      </script>
  </head>
  <body>
    <h2 id="subtitle">Property Graph - RDF Experimental Converter</h2>
    <section id="abstract">
      <p>PREC is a library designed to enable interoperability between RDF graphs
        and property graphs.</p>

      <p>This document mainly describes the PREC ontology: an ontology designed
        to describes the binding between the terms used in an RDF graph and the
        labels used in a property graph.</p>
    </section>
    <section>
      <h2>Introduction</h2>

      <p><a href="https://github.com/BruJu/PREC/">PREC</a> is composed of three modules:</p>
      <ul>
        <li>[= PREC-0 =], a Property Graph to RDF graph converter</li>
        <li>[= PRSC =] (PG to RDF, Schema-based Converter; pronounced like the french word <em>Presque</em>), an RDF Graph generated from PREC-0 to more readable graphs converter, based on schemas.</li>
        <li>[= PREC-C =] (PREC-Context), an RDF Graph generated from PREC-0 to more readable graphs converter</li>
      </ul>

      <p>
        To convert a Property Graph (PG) into an RDF graph, PREC operates a two
        steps conversion:
        <ul>
          <li>
            First, PREC-0 transforms the PG to an RDF graph, named PREC-0 graph.
            The PG is retrieved through usual PG APIs, like Cypher or Gremlin.
            The PREC-0 RDF graph is a literal description of the property graph.
          </li>
          <li>
            Then, if the user provided a context, the PREC-0 RDF graph is
            transformed into an idiomatic RDF graph by using the rules described
            in the context. There are two different rulesets: the PRSC ruleset
            and the PREC-C ruleset.
              <ul>
                <li>
                  The [= PRSC =] ruleset is easier to use and idiomatic RDF graphs can
                  be used to revert to a PG depending on the provided PRSC
                  context.
                </li>
                <li>
                  The [= PREC-C =] ruleset allows a more fine grained
                  control of the conversion, but is more verbose.
                </li>
              </ul>
          </li>
        </ul>
      </p>
      
      <p>
        To define the transformations to apply, PREC uses a <em>Context</em>
        provided by the user in
        <a href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html#turtle-star">Turtle-Star</a>
        format.
      </p>

      <aside class="note" title="Terminology">
        <p>
          The following terms are used to describe Property Graphs:
          <ul>
            <li><em>Node</em>, sometimes called <em>Vertex</em> in other works.</li>
            <li><em>Edge</em>, sometimes called <em>Relationship</em> in other works.</li>
            <li><em>Element</em>, something that is either a node or an edge.</li>
            <li>
              <em>Source node</em>, the node from which an edge starts.
              Sometimes called <em>start node</em> in other works.
            </li>
            <li>
              <em>Destination node</em>, the node from which an edge ends.
              Sometimes called <em>end node</em> or <em>target node</em> in
              other works.
            </li>
            <li>
              <em>Properties</em> are key-value pairs. In other works, the
              property key is sometimes named the <em>property name</em>.
            </li>
          </ul>
      </aside>

    </section>

    <section>
      <h2>PREC-0: From PGs to a literal transcription in RDF graph</h2>

      <p>
        The <dfn>PREC-0</dfn> module comunicates with a PG engine using an
        already existing API, for example Cypher, Gremlin or APOC, and extract
        the data to build a PREC-0 RDF graph: an RDF graph that describes the
        Property Graph very literally.
      </p>

      <section>
        <h3>Schema of the PREC-0 graphs</h3>
        <p>
          The current schema of PREC-0 graphs is as follows:<br>
          <img src="prec0schema.png" alt="The schema of PREC-0 graphs" style="width: 100%; height: auto;"/>
        </p>
        <p>
          A partial SHACL Shapes Graph is available at
          <a href="https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl">
            https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl
          </a>. This SHACL Shapes Graph should be conform on every PREC-0
          generated graph (graphs extracted by PREC without any context).
        </p>
      </section>

      
      <section>
        <h3>Terms used in PREC-0 graphs</h3>

        <p>
          The PREC ontology introduces some new types for the graphs generated
          by PREC-0. Note that the
          <a href="http://ii.uwb.edu.pl/pgo#Node">pgo:Node</a>
          and the 
          <a href="http://ii.uwb.edu.pl/pgo#Edge">pgo:Edge</a>
          types are used in the graphs generated by PREC-0.
        </p>

        <section>
          <h4><dfn data-lt="prec:CreatedVocabulary">http://bruy.at/prec#CreatedVocabulary</dfn></h4>
          
          <p>Type of IRIs that has been created by PREC and that
          should be mapped to an actual ontology.</p>

          <p>Types that are subtypes of [= prec:CreatedVocabulary =] are:
            <ul>
              <li><dfn class="lint-ignore" data-lt="prec:CreatedPropertyKey">http://bruy.at/prec#CreatedPropertyKey</dfn></li>
              <li><dfn class="lint-ignore" data-lt="prec:CreatedNodeLabel">http://bruy.at/prec#CreatedNodeLabel</dfn></li>
              <li><dfn class="lint-ignore" data-lt="prec:CreatedEdgeLabel">http://bruy.at/prec#CreatedEdgeLabel</dfn></li>
            </ul>
          </p>


        </section>

        <section>
          <h4><dfn data-lt="prec:PropertyKey">http://bruy.at/prec#PropertyKey</dfn></h4>

          <p>Type of property keys.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#PropertyKeyValue</h4>

          <p>Type of property values. Can be seed as the counterpart of
          <a href="http://ii.uwb.edu.pl/pgo#Property">pgo:Property</a> in the
          PREC-0 modelization.</p>
        </section>
      </section>

    </section>

    <section>
      <h2>Contexts</h2>

      <p>
        A context is a document, written in Turtle-star, that describes how to
        convert the different nodes, edges and properties in the property graph into an idiomatic
        RDF graph.
      </p>

      <section>
        <h3>Use of a context</h3>

        <p>The context can be automatically applied during the convertion of the Property Graph to RDF:</p>
        <ul>
          <li>
            To use a context during the extraction of a property graph, you can
            use the `-c /path/to/context` argument of the command line interface.
          </li>
          <li>For example, for a Neo4j graph for which you have already extacted
            the content in Json format with the APOC extension:
            <ul>
              <li>
                The command line to build a PREC-0 graph would be
                `prec apoc2rdf path_to_property_graph_content.json`
              </li>
              <li>
                The command line to build an idiomatic graph is
                `prec apoc2rdf path_to_property_graph_content.json -c path_to_context.ttl`
              </li>
            </ul>
          </li>
        </ul>
      
        <p>If you have already generated the PREC-0 graph, you can use the ApplyContext tool:</p>
        <ul>
          <li>`prec applyContext path_to_prec0_graph.ttl path_to_context.ttl`</li>
        </ul>
      </section>

      <section>
        <h3>Rulesets</h3>

        <p>
          There are two different rulesets for contexts: PRSC and PREC-C. We
          recommand to use the PRSC ruleset if possible as it is easier to use.
        </p>

        <p>
          Rules usually target some entities, and have some constraints on which
          entities it targets. Targettable entities, <em>i.e.</em> first class
          citizen, are:
          <ul>
            <li>For PRSC: nodes and edges.</li>
            <li>For PREC-C: nodes, edges and properties.</li>
          </ul>
        </p>
      </section>

      <section>
        <h3>The templating system</h3>

        <p>
          PREC uses a custom templating system. Triples that should be produced
          by a rule are the ones described by embed triples used as the object
          of triples for which the predicate is <em>prec:produces</em>.
        </p>

        <p>
          When the triples are produced, some terms, usually in the
          <em>pvar</em> namespace are replaced with terms depending on the
          data from the property graph.
        </p>

        <p>
          Each triple that is used as an object of <em>prec:produces</em> is
          called a <dfn>template triple</dfn>. The set of all template triples
          of a resource, <em>i.e.</em> for a given resource, the set of all
          objects of triples that have as the subject the resource and as the
          predicate <em>prec:produces</em>, is named a
          <dfn>template graph</dfn>.
        </p>

        <aside class="example" title="A template graph">

          <p>
            In the following example, the rule `ex:PersonForm` is applied for
            the nodes that have the label "Person". For these node, one triple
            will be produced: the one described by the triple
            `ex:PersonForm prec:produces << pvar:self ex:hasLabel ex:Person >>`.
            However, `pvar:self` will be replaced by a blank node or an IRI
            specific to each node for which the rule applies.
          </p>
          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
              PREFIX prec: <http://bruy.at/prec#>
              PREFIX pvar: <http://bruy.at/prec-trans#>
              PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
              PREFIX ex:   <http://example.org/>

              ex:PersonForm a prec:PRSCNodeRule ;
                prec:label "Person" ;
                prec:produces
                  << pvar:self ex:hasLabel ex:person >> .
            -->
          </pre>
        </aside>

        <p>
          This templating system allows the user to write triples that are
          very close to the one that are produced. Moreover, because there are
          no variables, template graphs can be written in plain Turtle-star
          files.
        </p>
      </section>
    </section>

    <section>
      <h2><dfn>PRSC</dfn> - Schema driven mapping</h3>

        <p>
          PRSC contexts are contexts that transform all nodes and edges that
          share a common type by using a given RDF representation.
          A type is defined as whenever the element is an edge or a node,
          the list of labels and the list of properties of the element.
        </p>

        <p>
          This kind of context identify every node and edges to a schema, and the
          transformation of every schema from PG to RDF must be defined.
        </p>

        <section>
          <h3>Writing PRSC rules</h3>

          <strong>List of valid IRIs for a PRSC rule are:</strong>
          <ul>
            <li>`prec:PRSCNodeRule` - Type for rules that target nodes</li>
            <li>`prec:PRSCEdgeRule` - Type for rules that target edges.</li>
            <li>`prec:label` - A label the node must have</li>
            <li>`prec:propertyKey` - A property the node must have</li>
            <li>`prec:produces` - describes how to represent the elements that complies to the rule</li>
          </ul>

          <strong>Placeholders for the template graph</strong>
          <ul>
            <li>`pvar:self` - The identifier for the element (node or edge)</li>
            <li>`pvar:source` - Edges only, source of the edge</li>
            <li>`pvar:destination` - Edges only, destination of the edge</li>
            <li>`"property key"^^prec:valueOf` - Placeholder for the value of the property "property name"</li>
          </ul>
          
          <aside class="example" title="Example of a PRSC context">

          <p>
            After cloning the repo, test it by running
            `npx ts-node prec apoc2rdf data\ex2_annlikesdan1.json -c data\ex2_prsc.ttl`
          </p>

          <p><strong>Property graph:</strong> (its Neo4j APOC representation is stored in `data\ex2_annlikesdan1.json`)</p>
          <pre>
            ( ann   :Person { name: "Ann" } ) -[ :likes ]-> ( dann :Person { name: "Dan" } )
          </pre>

          <p><strong>PRSC context:</strong></p>
          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
              PREFIX prec: <http://bruy.at/prec#>
              PREFIX pvar: <http://bruy.at/prec-trans#>
              PREFIX ex:   <http://example.org/>
              PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

              ex:PersonForm a prec:PRSCNodeRule ;
                prec:label "Person" ;
                prec:propertyKey "name" ;
                prec:produces
                  << pvar:self ex:hasLabel ex:person >> ,
                  << pvar:self ex:name "name"^^prec:valueOf >> .

              ex:LovesForm a prec:PRSCEdgeRule ;
                prec:label "Likes" ;
                prec:produces << pvar:source ex:loves pvar:destination >> .
            -->
          </pre>

          <p><strong>Output:</strong></p>
          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
          <!--
            @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
            @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
            @prefix pgo: <http://ii.uwb.edu.pl/pgo#>.
            @prefix prec: <http://bruy.at/prec#>.
            @prefix nodeLabel: <http://www.example.org/vocab/node/label/>.
            @prefix nodeProperty: <http://www.example.org/vocab/node/property/>.
            @prefix edgeLabel: <http://www.example.org/vocab/edge/label/>.
            @prefix edgeProperty: <http://www.example.org/vocab/edge/property/>.

            _:node9 <http://example.org/hasLabel> <http://example.org/person>;
                <http://example.org/name> "Ann";
                <http://example.org/loves> _:node10.
            _:node10 <http://example.org/hasLabel> <http://example.org/person>;
                <http://example.org/name> "Dan".
          -->
        </pre>

        </aside>
      </section>


      <section>
        <h3>Well-behaved PRSC contexts</h3>

        <p>
          The PRSC contexts that follow the given rules are said well-behaved:
          <ul>
            <li>All template triples contain the term `pvar:self`</li>
            <li>
              All rules have a <em>signature template triple</em>, a triple
              whose [= characterization =] can only be found for this rule.
            </li>
            <li>
              All properties must have a <em>unique template triple</em>, a
              triple whose [= characterization =] is unique among the
              template triples inside the template graph of the rule. If the
              element is an edge, the source and the destination must also have
              a unique template triple.
            </li>
            <li>
              <em>Edge-unique extension:</em> Edge rules can violate the first
              criterion if all template triples in the template graph contain
              `pvar:source`, `pvar:destination`, are
              <em>signature template triples</em> and
              <em>unique template triples</em>.
            </li>
          </ul>
        </p>

        <p>
          You can check if a PRSC context is well-behaved with
          `npx ts-node prec prscCheckWellBehaved path-to-your-context`:
          <ul>
            <li>`npx ts-node prec prscCheckWellBehaved data\ex2_prsc_wb.ttl`: Ok</li>
            <li>`npx ts-node prec prscCheckWellBehaved data\ex2_prsc.ttl`: Ok thanks to the edge-unique extension</li>
            <li>`npx ts-node prec prscCheckWellBehaved data\ex2_prsc_bad.ttl`: Not ok because a property is missing</li>
          </ul>
        </p>

        <p>
          The <dfn data-lt="characterization">characterization of a template
            triple</dfn> can be considered as being equal to the triple where:
            <ul>
              <li>Terms in the `pvar` namespace and blank nodes are
                substituted with the term `pvar:element`
              </li>
              <li>
                Literals, including the one whose datatype is `prec:valueOf` are
                substituted with the literal `"Literal"`.
              </li>
            </ul>
        </p>

        <p>
          If an RDF graph is generated from a PRSC well behaved context:
          <ul>
            <li>
              The RDF graph conversion is guaranted to not lose any information
              compared with the property graph.
            </li>
            <li>
              The inverse operation, <em>i.e.</em> converting the RDF graph
              back into the original PREC-0 graph, and by extension to an
              isomorphic property graph to the one that produced it, can be
              performed by the PREC engine.
            </li>
          </ul>
        </p>
      </section>
    </section>

    <section>
      <h2><dfn data-lt="PREC-Context">PREC-C</dfn> - Low level mapping</h2>
      
        <p>
          Unlike PRSC contexts that only have rules for nodes and edges, PREC-C
          context ruleset can target node, edges and properties.
        </p>


        <section>
          <h3>Example of a context</h3>
  
          <aside class="example">
            <p>
              In this section, we will present the ontology through a practical
              example. Considering a property graph with the following data
              (exposed in a format similar to a Cypher query):
            </p>
  
            <pre>
              ( haddock   :Person { name: "Haddock", firstName: "Archibald" } ),
              ( snowy     :Animal { name: "Snowy"  } ),
              ( the_serie :Serie  { name: "The Adventures of Tintin" } ),
  
              ( haddock ) -[ :appears { since: "The Crab with the Golden Claws"   } ]->( the_serie ),
              ( snowy   ) -[ :appears { since: "Tintin in the Land of the Soviets" }]->( the_serie ),
              ( haddock ) -[ :knows ]->( snowy )
            </pre>
  
            <p>
              PREC enables us to convert this Property Graph into an RDF graph.
              The graph generated without any context is very verbose, and will
              not be displayed here. Instead, we are going to write a context to
              produce a small and readable graph.
            </p>
  
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
                @prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
                @prefix prec: <http://bruy.at/prec#> .
                @prefix pvar: <http://bruy.at/prec-trans#> .
                @prefix pgo:  <http://ii.uwb.edu.pl/pgo#> .
  
                # We want properties to be written in the RDF-graph as
                # [the node or edge] [iri of the property] [the value]
                prec:Properties prec:templatedBy prec:DirectTriples .
  
                # We want edges to be written in the RDF-graph as
                # [the source] [the label] [the destination]
                # and use RDF-star for properties
                prec:Edges prec:templatedBy prec:RdfStarUnique .
  
                # == Properties
  
                # The name of a person is its family name
                [] a prec:PropertyRule ;
                  prec:propertyKey "name" ;
                  prec:propertyIRI <http://schema.org/familyName> ;
                  prec:label "Person" ; prec:onKind prec:Node .
                
                [] a prec:PropertyRule ;
                  prec:propertyKey "firstName" ;
                  prec:propertyIRI <http://schema.org/givenName> .
  
                # Other names are names
                [] a prec:PropertyRule ;
                  prec:propertyKey "name" ;
                  prec:propertyIRI <http://schema.org/name> .
                
                # We use an IRI from dbpedia for the since property
                # As writing rules for simple things is very long, we are
                # going to use a syntactic sugar
                <http://dbpedia.org/property/debut> prec:IRIOfProperty "since" .
  
                # == Node labels
                <http://dbpedia.org/resource/Person> prec:IRIOfNodeLabel "Person" .
                <http://dbpedia.org/resource/Animal> prec:IRIOfNodeLabel "Animal" .
                <http://dbpedia.org/class/yago/Series108457976> prec:IRIOfNodeLabel "Serie" .
  
                # == Edges
                <http://schema.org/knowsAbout> prec:IRIOfEdgeLabel "knows" .
                <http://schema.org/knowsAbout> prec:IRIOfEdgeLabel "knows" .
  
                # Map appears to schema:character. One problem of schema:character
                # is that is expect the serie as the subject and the character as
                # an object, but we can fix the order!
                [] a prec:EdgeRule ;
                  prec:label "appears" ;
                  # We want the destination to be the source and the destination
                  # to be the source so let's write our own template!
                  prec:templatedBy [
                    a prec:EdgeTemplate ;
                    prec:produces
                      # Assert the triple
                      <<    pvar:destination pvar:edgeIRI pvar:source               >> ,
                      # Keep the provenance
                      << << pvar:destination pvar:edgeIRI pvar:source >> a pgo:Edge >>
                  ] ;
                  # Properties will use the following term as their subject
                  prec:selfIs << pvar:destination pvar:edgeIRI pvar:source >> ;
                  # prec:edgeIRI will actually replace pvar:edge with schema:character
                  prec:edgeIRI <http://schema.org/character> .
              -->
            </pre>
  
            <p>
              The produce RDF-graph will be isomorphic to be following:
            </p>
  
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # Note that Haddock have no http://schema.org/name
              _:haddock a pgo:Node, <http://dbpedia.org/resource/Person>;
                  <http://schema.org/givenName> "Archibald";
                  <http://schema.org/familyName> "Haddock".
              
              _:snowy a pgo:Node, <http://dbpedia.org/resource/Animal>;
                  <http://schema.org/name> "Snowy".
              
              _:adventures_of_tintin a pgo:Node, <http://dbpedia.org/class/yago/Series108457976>;
                  <http://schema.org/name> "The Adventures of Tintin";
                  # The edge have been properly inverted
                  <http://schema.org/character> _:haddock, _:snowy.     
  
              _:haddock <http://schema.org/knowsAbout> _:snowy.
              <<_:haddock <http://schema.org/knowsAbout> _:snowy>> a pgo:Edge.
                
              # When did every character appear?
              <<_:adventures_of_tintin <http://schema.org/character> _:haddock>> a pgo:Edge;
                  <http://dbpedia.org/property/debut> "The Crab with the Golden Claws".
  
              <<_:adventures_of_tintin <http://schema.org/character> _:snowy>> a pgo:Edge;
                  <http://dbpedia.org/property/debut> "Tintin in the Land of the Soviets".
              -->
            </pre>
  
            <p>
              Note that in this example, while the produced output is easy to
              read and reuse existing ontologies, we are not conforming to the DBPedia
              usual schema, as in DBpedia, `<http://dbpedia.org/property/debut>`
              would be used with the character as the subject and the book (and
              not its name) as the object ; and in the current state of the
              ontology we can not do better. This is one of the weakness of
              the ontology: it can not conform to every schema.
            </p>
          </aside>
        </section>


      
      <section>
        <h3>Reserved IRIs</h4>

        <p>IRIs in the `prec` namespace are reserved for the ontology.</p>

        <p><a href="https://github.com/BruJu/PREC/">The default implementation</a>
          reserves for itself the IRIs prefixed with `_` and `__`. Therefore,
          as they are reserved for implementation, using them in a context
          results in undefined behaviour.</p>
      </section>

      <section>
        <h3>General directives</h3>

        <section>
          <h4><dfn data-lt="prec:KeepProvenance" class="lint-ignore">http://bruy.at/prec#KeepProvenance</dfn>
          and <dfn class="lint-ignore">http://bruy.at/prec#flagState</dfn>
          </h4>

          <p>
            By default, a triple is created for each node / edge /
            property label / property blank node between its IRI / blank node
            and the corresponding type.
          <br>If this flag is set to `false`, the triples in the form
            `ex:node1 a pgo:Node` are deleted from the output graph.</p>

          <aside class="example">
            <p>Keep the types (default behaviour).</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState true .
              -->
            </pre>

            <p>Remove the types.</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState false .
              -->
            </pre>
          </aside>
        </section>
      </section>

      <section>
        <h3>Change the schema of the generated graph</h3>

        <p>[= PREC-0 =] generates an RDF Graph with a certain format. It is
          possible to change the way the properties and the edges are
          represented in the RDF graph.</p>

        <p>By default:</p>
        <ul>
          <li>Edges are materialized using a standard RDF Reification</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:theEdge a pgo:Edge ;
              rdf:subject _:sourceNode ;
              rdf:predicate [ rdfs:label "TheLabel" ] ;
              rdf:object _:targetNode .
            -->
          </pre>
          <li>Properties are materialized like in the following example:</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:eitherTheNodeOrTheEdge :propertyKey _:aBlankNode .
            _:aBlankNode rdf:value "The value of the property" .
            
            :propertyKey a prec:PropertyKey ; rdfs:label "The name of the property" .
            _:aBlankNode a prec:PropertyKeyValue .
            -->
          </pre>
        </ul>

        <p>[= PREC-Context =] is able to change the format used to represent the
          properties and the edges by using templates.
          <br>In PREC, we call a <em>template</em> the format wanted by the user.</p>

          <section>
            <h4><dfn data-lt="prec:templatedBy">http://bruy.at/prec#templatedBy</dfn></h4>

            <p>
              Predicate used to state that the components affected by the
              subject rule must be represented in the format described in the
              object.
            </p>

              <aside class="example">
                <p>
                  A context that requires every edge to be represented
                  with the Singleton Property pattern.
                </p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  PREFIX prec: <http://bruy.at/prec#>
                  prec:Edges prec:templatedBy prec:SingletonProperty .
                  -->
                </pre>
              </aside>

          </section>

        <section>
          <h4>Edge templates</h4>

          <p>
            [= PREC-Context =] uses a special IRI for the set of every
            edges and defines some base templates that are implcitely
            defined in every context.
          </p>

          <p>Thanks to these IRIs and [= prec:templatedBy =], it is possible to
            tranform the representation used for every edge from the standard
            RDF Reification to any template.
          </p>
          
          <section>
            <h5><dfn data-lt="prec:Edges">http://bruy.at/prec#Edges</dfn></h5>

            <p>
              [= prec:Edges =] is the domain of every edge. A template that is
              applied to this IRI will be applied to every edge.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RDFReification">http://bruy.at/prec#RDFReification</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RDFReification .`
              <br />Edges must be represented by using the standard RDF
              Reification. This is the default behaviour.
            </p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarUnique">http://bruy.at/prec#RdfStarUnique</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RdfStarUnique .`
              <br>Edges are modeled as a triple that is added to th
               graph, and meta properties are added using RDF-star. This
               templatewill cause information loss if there are two edges with
               the same label between two nodes.
            </p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarOccurrence">http://bruy.at/prec#RDFStarOccurrence</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RDFStarOccurrence .`
              <br>Edges are modeled as an RDF-star occurence: a blank
              node represents the occurrence and [= prec:occurrenceOf =] is used
              to link the node to the triple it is an occurence of.
            </p>

            <section>
              <h5><dfn data-lt="prec:occurrenceOf">http://bruy.at/prec#occurrenceOf</dfn></h5>

              <p><em>
                This IRI is used in the generated graphs and should not be used
                in contexts as a "keyword".
              </em></p>

              <p>
                Specifies for which triple the edge is an occurrenceOf.
                The semantics is identic to the one used in the
                <a href="https://w3c.github.io/rdf-star/cg-spec/2021-04-13.html#occurrences">
                  latest RDF-star draft
                </a>.
              </p>

              <aside class="example">
                <p>
                  Joe Biden "worked" for the White House from 2009 to 2017 as
                  the vice president and since 2021 as the president.
                </p>
                

                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  _:first  prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  _:second prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  
                  _:first  :from 2009; :to 2017 ; :role "Vice President" .
                  _:second :from 2021;            :role "President"      .
                  -->
                </pre>

                <p><em>Why do we need this?</em></p>
                
                <p>If we write</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >> :from 2009; :to 2017 ; :role "Vice President" .
                  << :joe_biden :workingFor :white_house >> :from 2021;            :role "President"      .
                  -->
                </pre>
                
                <p>it is equivalent to writing</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >>
                    :from 2009, 2021 ;
                    :to 2017 ;
                    :role "Vice President", "President" .
                  -->
                </pre>
                
                <p>
                  While we can deduce from the semantic of `:from`, `:to` and
                  years that Joe Biden worked from 2009 to 2017 then from 2021
                  for the White House, and while we know that he worked as the
                  Vice President and the President, we are unable to distinguish
                  when he was Vice President and when he was President.
                </p>
              </aside>
            </section>
          </section>
          <section>
            <h5><dfn data-lt="prec:SingletonProperty">http://bruy.at/prec#SingletonProperty</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:SingletonProperty .`
              <br>Edges must be represented by using singleton properties.
            </p>
          </section>
        </section>

        <section>
          <h4>Property templates</h4>

          <p>The template used for properties can also be redefined.</p>

          <section>
            <h5><dfn data-lt="prec:Properties">http://bruy.at/prec#Properties</dfn></h5>

            <p>
              The domain of every properties. A triple that has
              [= prec:Properties =] as a subject is equivalent to three triples,
              one with [= prec:NodeProperties =] as the subject, another with
              [= prec:EdgeProperties =] as the subject and another
              with [= prec:MetaProperties =] as the subject.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:NodeProperties">http://bruy.at/prec#NodeProperties</dfn></h5>

            <p>The domain of every node properties. The properties on
              edges will not be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeProperties">http://bruy.at/prec#EdgeProperties</dfn></h5>

            <p>The domain of every edge properties. The properties on
              nodes will not be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:MetaProperties">http://bruy.at/prec#MetaProperties</dfn></h5>

            <p>
              The domain of every meta properties (properties on properties).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:Prec0Property">http://bruy.at/prec#Prec0Property</dfn></h5>

            <p>
             This is the default behaviour.
            </p>

            
            <aside class="example">
              <p>Bob lives in Paris and is a tenant of his appartment.</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:bob :lives_in [
                    rdf:type prec:PropertyKeyValue ;
                    rdf:value "Paris" ;
                    :status [ rdf:value "Tenant" ; rdf:type prec:PropertyKeyValue ]
                ] .
                
                :lives_in a prec:PropertyKey ; rdfs:label "lives_in" .
                :status  a prec:PropertyKey  ; rdfs:label "status" .
                -->
              </pre>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:DirectTriples">http://bruy.at/prec#DirectTriples</dfn></h5>

            <p>
              Properties are modeled without any blank node
              (`:node :propertyKey :thePropertyValueLiteral`), and the meta
              properties are represented by using RDF-star.
            </p>
          </section>
        </section>

        <section>
          <h4>Writting your own templates</h4>

          <p>
            So far, this document described how to use predefined templates. It
            is also possible to write you own templates.
          </p>

          <p>
            Templates uses the `pvar` namespace (http://bruy.at/prec-trans#) as
            variable/placeholders. pvar can be seen as a way to write `?` in a
            Turtle file without actually using a real variable.
          </p>

          <aside class="note">
            <p>
              Every built-in template is actually defined in a turtle file that
              is loaded and included to every context you write.
            </p>
          </aside>

          <section>
            <h5><dfn data-lt="prec:produces">http://bruy.at/prec#produces</dfn></h5>

            <p>
              Used to state the list of RDF triples that composes the template.
              When the template is applied, every triple used in the default
              PREC-0 representation will be replaced with the triples that
              composes the template (after replacing the placeholders with
              their actual value).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeTemplate">http://bruy.at/prec#EdgeTemplate</dfn></h5>

            <p>The type of templates that can be used for edges.</p>

            <p>`EdgeTemplate`s use the following variable:</p>
            <ul>
              <li>`pvar:edge`: The RDF node that was created to identify the edge.</li>
              <li>`pvar:source`: The RDF node that represents the PG source node of the edge.</li>
              <li>`pvar:destination`: The RDF node that represents the PG destination edge.</li>
              <li>`pvar:edgeIRI`: The RDF node that represents the label of the edge.</li>
              <li>`pvar:label`: The label of the edge, as a string literal.</li>
              <li>`prec:selfIs`: enables to specify to which term bind the properties of the edge.</li>
            </ul>

            <p>
              We are going to show how a user can define its own template

            <aside class="example">
              <p>An [= prec:EdgeTemplate =] that is the identity / the standard RDF Reification</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RDFReification a prec:EdgeTemplate ;
                  prec:produces
                    << pvar:edge a pgo:Edge >> ,
                    << pvar:edge rdf:subject      pvar:source          >> ,
                    << pvar:edge rdf:predicate    pvar:edgeIRI >> ,
                    << pvar:edge rdf:object       pvar:destination     >> ;
                  prec:selfIs pvar:edge
                .
                -->
              </pre>

              <p>
                Note that `prec:RDFReification` is the pattern that is matched
                against, which means templating an edge with the
                `prec:RDFReification` will result in the same graph.
              </p>
            </aside>

            <aside class="example">
              <p>
                [= prec:RDFStarUnique =] is a template that assumes that every
                edges between the same two nodes have a different label.
              </p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RdfStarUnique a prec:EdgeTemplate ;
                  prec:produces
                    <<    pvar:source pvar:edgeIRI pvar:destination               >> , # (a)
                    << << pvar:source pvar:edgeIRI pvar:destination >> a pgo:Edge >> ; # (b)
                  prec:selfIs
                    << pvar:source pvar:edgeIRI pvar:destination >> .                  # (c)
                .
                -->
              </pre>

              <p>If we suppose we have the following RDF Graph:</p>
              
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:edge1 a pgo:Edge ;
                  rdf:subject _:src ;
                  rdf:predicate _:label ;
                  rdf:object _:dest ;
                  _:propPlace _:propValuePlace ;
                  _:propTime  _:propValueTime .
                -->
              </pre>

              <p>The variables will match as follow:</p>

              <table>
                <tr><th>Variable name</th>                 <th>Value</th>               </tr>
                <tr><td> `pvar:edge`                  </td><td> `_:edge1`          </td></tr>
                <tr><td> `pvar:source`                </td><td> `_:src`            </td></tr>
                <tr><td> `pvar:destination`           </td><td> `_:dest`           </td></tr>
                <tr><td> `pvar:edgeIRI        `       </td><td> `_:label`          </td></tr>
              </table>

              <p>The triples `_:edge1 _:propPlace _:propValuePlace (1)` and 
              `_:edge1 _:propTime  _:propValueTime (2)` are related to
              properties.</p>
              
              <p>The produced graph will be the following:</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:src _:label _:dest .                  # From (a)
                << _:src _:label _:dest >> a pgo:Edge . # From (b)
                << _:src _:label _:dest >> _:propPlace _:propValuePlace . # From (c) using (1)
                << _:src _:label _:dest >> _:propTime  _:propValueTime  . # From (c) using (2)
                -->
              </pre>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:PropertyTemplate">http://bruy.at/prec#PropertyTemplate</dfn></h5>

            <p>The type of templates that can be used for properties.</p>
            
            <p>`prec:PropertyTemplate`s use the following variables:</p>
            <ul>
              <li>`pvar:holder`: The RDF node that was created to identify the edge or the node.</li>
              <li>`pvar:propertyKey`: The node that represents the edge label.</li>
              <li>`pvar:label`: The label of the property key, as a string literal.</li>
              <li>`pvar:property`: The blank node that represents the property.</li>
              <li>`pvar:propertyValue`: The literal that contains the property value.</li>
              <li>`pvar:individualValue`: Most of the time equals to `propertyValue`. If `propertyValue` is an rdf list, `individualValue` will match each individual literal contained in the list instead of the list itself.</li>
              <li>`prec:selfIs`: The term to which the meta properties must be bound.</li>
            </ul>

            <p>
              The substitution mecanism is the same as described in the
              [= prec:EdgeTemplate =] section.
            </p>

            <p>Some restrictions exists on property templates:
              <ul>
                <li>
                  `pvar:holder` can only appear in the "subject-star" position.
                  The `subject-star` position is defined recursively as either
                  the subject of the quad if it is not a nested quad, or the
                  "subject-star" of the quad in the subject position. In other
                  words, when the Triple-star is written in the N-Triples-star
                  format, it is the first non RDF-star term that appears for
                  this triple.
                </li>
                <li>
                  Every embedded triple must be asserted by the template.
                </li>
              </ul>
            </p>
            <p>
              These restriction exists to make combinations between an
              edge template and different (meta)-property templates
              possible. These restrictions will be attenuated in the future.
            </p>
          </section>
        </section>

      <section>
        <h3>Rules</h3>

        <p>
          Rules are the main way to modify a [= PREC-0 =] RDF graph. They let
          the user modify specific elements of the graphs by:
          <ul>
            <li>filtering some of the edges or properties</li>
            <li>applying a specific template to these nodes, edges and properties</li>
          </ul>
        </p>

        <p>
          As one can expect, there are two different kind of rules : rules for
          edges ([= prec:EdgeRule =]) and rules for properties
          ([= prec:PropertyRule =]).
        </p>

        <section>
          <h4>Edge rules</h4>

          <p>
            Edge rules aim to modify the way the property graph
            edges are materialized in the RDF Graph.
          </p>

          <aside class="example">
            <p>
              A rule that only applies to edges with the label "Like"
              and for which both the source and the destination node have the
              label "Person". This rule will materialize these edge
              as a standard RDF Triple, with `ex:like` as the predicate
              (for example `:alice ex:like :bob` will be produced).
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [] a prec:EdgeRule ;
                # - Filtering
                # Like must be the edge label
                prec:label "Like" ;
                # The source node must have the label Person
                prec:sourceLabel      "Person" ;
                # The destination node must have the label Person
                prec:destinationLabel "Person" ;
                # - Transformation
                # Replace the generated IRI for the edge label with ex:like
                prec:edgeIRI ex:like ;
                # Modelize this edge by using the prec:RDFStarUnique
                # template instead of a standard RDF Reification
                prec:templatedBy prec:RDFStarUnique .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:EdgeRule">http://bruy.at/prec#EdgeRule</dfn></h5>

            <p>
              The type of edge rules. The [= PREC-Context =] engine
              currently requires the edge rules to be properly typed to
              be able to discover them.
            </p>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:label">http://bruy.at/prec#label</dfn></h5>

            <p>
              States that the edge must have the given label to match
              the rule. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:edgeIRI">http://bruy.at/prec#edgeIRI</dfn></h5>

            <p>
              States that the generated node for the edge must be
              replaced with the given IRI.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:sourceLabel">http://bruy.at/prec#sourceLabel</dfn></h5>

            <p>
              States that the edge source node must have the given
              label. The value must be a literal.
            </p>

            
            <aside class="example">
              <p>
                Let us consider we have the following property graph, with
                three nodes: one of type Person, one of type Cat and one of type
                Food. The Person likes the Cat and the Cat likes the Food.
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                                 (a)                     (b)
                [ :Person ] --- :Like -- > [ :Cat ] --- :Like -- > [ :Food ]
                -->
              </pre>

              <p>
                We can write the following edge rule:
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:Edges prec:templatedBy prec:RDFStarUnique .

                # Matches (a)
                :firstRule a prec:EdgeRule ;
                  prec:label "Like" ;
                  prec:sourceLabel "Person" ;
                  prec:edgeIRI ex:likes .
                
                # Matches (b)
                :secondRule a prec:EdgeRule ;
                  prec:label "Like" ;
                  prec:sourceLabel "Cat" ;
                  prec:edgeIRI ex:eats .
                -->
              </pre>

              <p>The output graph would be the following:</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                # Matches :firstRule, also applies the new default template
                _:person ex:likes _:cat  {| a pgo:Edge |} .
                # Matches :secondRule, also applies the new default template
                _:cat    ex:eats  _:food {| a pgo:Edge |} .

                _:person a pgo:Node, [ rdfs:label "Person" ].
                _:cat    a pgo:Node, [ rdfs:label "Cat"    ].
                _:food   a pgo:Node, [ rdfs:label "Food"   ].
                -->
              </pre>
            </aside>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:destinationLabel">http://bruy.at/prec#destinationLabel</dfn></h5>

            <p>
              Same as [= prec:sourceLabel =], but for the destination node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfEdgeLabel">http://bruy.at/prec#IRIOfEdgeLabel</dfn></h5>

            <p>
              Shortcut to define a edge rule that matches edges
              with a specific label and map the edge label to a specific
              IRI.
            </p>

            <p>The two following contexts are equivalents:

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :iri prec:IRIOfEdgeLabel "Label" .
                -->
              </pre>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:EdgeRule ;
                  prec:label "Label" ;
                  prec:edgeIRI :iri .
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifiying a template</h5>

            <p>
              Like [= prec:Edges =], it is possible to define a target
              template for edge rules by using the [= prec:templatedBy =]
              predicate. It is also possible to apply any
              [= prec:SubstitutionPredicate =]s, and not only
              [= prec:edgeIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4>Property rules</h4>

          <p>
            A property rule is a rule that can be applied to a property. In a
            similar fashion as edge rules, a property rule targets some
            properties, and can modify how they are materialized in the graph.
          </p>

          <aside class="example">
            <p>
              Let us consider we have the following property graph, with
              three nodes: one of type Person, one of type Cat and one of type
              Food. The Person likes the Cat and the Cat likes the Food.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person { name: "Macron", givenName: "Emmanuel" }]
                  |
                [ :Owns { since: 2017 } ]
                  |
                 \|/
              [ :Animal { name: "Nemo" }]
              -->
            </pre>

            <p>
              We can use the following context:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:Properties    prec:templatedBy prec:DirectTriples .

              # A rule for the name property of nodes of type Person
              :humanNameRule a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/familyName> ;
                prec:label "Person" .
              
              # A rule for the name property of other things
              :otherNameRule a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/name> .
              
              # Other rules
              :givenNameRule a prec:PropertyRule ;
                prec:propertyKey "givenName" ;
                prec:propertyIRI <http://schema.org/givenName> .
              
              # The following could have been written
              # [] a prec:PropertyRule ; prec:propertyKey "since" ; prec:propertyIRI :since
              :since prec:IRIOfProperty "since" .
              -->
            </pre>

            <p>The resulting graph would be the (isomorphic to) the following:</p>


            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:macron a pgo:Node, [ rdfs:label "Person" ] .
              _:nemo   a pgo:Node, [ rdfs:label "Animal" ] .

              # Matches :humanNameRule
              _:macron <http://schema.org/familyName> "Macron" .
              # Matches :givenNameRule
              _:macron <http://schema.org/givenName>  "Emmanuel" .

              # Matches :otherNameRule
              _:nemo <http://schema.org/name> "Nemo" .

              # The edge
              _:macronownsnemo a pgo:Edge ;
                rdf:subject   _:macron ;
                rdf:object    _:nemo ;
                rdf:predicate [ rdfs:label "Owns" ] .
              # The property of the edge matches the prec:IRIOfProperty rule
              _:macronownsnemo :since 2017 .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:PropertyRule">http://bruy.at/prec#PropertyRule</dfn></h5>

            <p>
              The type of property rules. The [= PREC-Context =] engine
              currently requires the property rules to be propertly typed to
              be able to discover them.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyKey">http://bruy.at/prec#propertyKey</dfn></h5>

            <p>
              The key / the name of the matched properties. The value must be a
              literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyIRI">http://bruy.at/prec#propertyIRI</dfn></h5>

            <p>
              States the IRI to use for this property name. Its value will be
              used instead of the generated node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:label">http://bruy.at/prec#label</dfn></h5>

            <p>
              States the label that the node or edge must have for the rule to
              apply. If there are several values for [= prec:label =], the node
              must have every labels. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:any">http://bruy.at/prec#onKind</dfn></h5>

            <p>
              The property rule can only be applied if it is a property on a
              node (prec:Node as the object) or an edge (prec:Edge as the
              object).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfProperty">http://bruy.at/prec#IRIOfProperty</dfn></h5>

            <p>
              Enables to declare simple property rules with only one triple,
              instead of three.
            </p>

            <p>The two following rules are equivalent:
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :someIRI prec:IRIOfProperty "APropertyName" .
                -->
              </pre>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:PropertyRule ;
                  prec:propertyKey "APropertyName" ;
                  prec:propertyIRI :someIRI
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifying a template</h5>

            <p>
              Like [= prec:Properties =], [= prec:NodeProperties =] and
              [= prec:EdgeProperties =], it is possible to specify a
              edge for a specific property rule thanks to [= prec:templatedBy =]
              and to use [= prec:SubstitutionPredicates =] other than
              [= prec:propertyIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4><dfn data-lt="prec:priority">http://bruy.at/prec#priority</dfn></h4>

          <p>
            By default, [= PREC-Context =] tries to apply rules from the more
            specific to the less specific. While the order of the rules is
            deterministic, the user may prefer to use another.
            [= prec:priority =] enables to change the order of the rules.
          </p>

          <aside class="example">
            <p>
              With this context, thanks to the priority, if an edge
              has a source label that is both an animal and a person, the
              `:personLike` rule is guaranteed to be applied.
            </p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              :personLike a prec:EdgeRule ;
                prec:label "Like" ;
                prec:sourceLabel "Person" ;
                prec:priority 2 ;
                prec:edgeIRI ex:likes .
                
              :catLike a prec:EdgeRule ;
                prec:label "Like" ;
                prec:sourceLabel "Animal" ;
                prec:priority 1 ;
                prec:edgeIRI ex:kinds_of_accept .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4><dfn data-lt="prec:IRIOfNodeLabel">http://bruy.at/prec#IRIOfNodeLabel</dfn></h4>

          <p><em>Usage</em>: ` :IRIToMapTo prec:IRIOfNodeLabel "Label" .`</p>

          <p>
            The last kind of labels that can be remapped are node labels. Node
            labels IRIs can be mapped with [= prec:IRIOfNodeLabel =], in a
            similar fashion as [= prec:IRIOfEdgeLabel =].
          </p>

          <p>
            [= prec:IRIOfNodeLabel =] states that the node labels equals to
            its object (`"Label"`) should be mapped to the IRI stated as the
            subject of the triple (`:IRIToMapTo`), instead of generating /
            keeping a generated a blank node or IRI.
          </p>

          <aside class="example">
            <p>Let us consider the following property graph with two nodes, one
              with the label Person and one with the label Animal:
            </p>
            
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person ]    [ :Animal ]
              -->
            </pre>

            <p>
              [= PREC-0 =] will convert this graph into the following RDF graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node ; [ rdfs:label "Person" ] .
              _:node2 a pgo:Node ; [ rdfs:label "Animal" ] .
              -->
            </pre>

            <p>Let us consider the following context:</p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              schema:Person prec:IRIOfNodeLabel "Person" .
              schema:Animal prec:IRIOfNodeLabel "Animal" .
              -->
            </pre>

            <p>
              [= PREC-Context =] will transform the [= PREC-0 =] graph into
              the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node, schema:Person .
              _:node2 a pgo:Node, schema:Animal .
              -->
            </pre>
          </aside>

          <section>
            <h5>Complete node rules</h5>

            <p>
              Rules can also be written for node labels. Here is the vocabulary
              related to node labels:
            </p>

            <ul>
              <li><dfn data-lt="prec:NodeLabelTemplate">http://bruy.at/prec#NodeLabelTemplate</dfn>:
                Type of node  templates. The variables that can be used are the
                following:
                <ul>
                  <li>`pvar:node`: The blank node or the IRI that represents PG node</li>
                  <li>`pvar:nodeLabelIRI`: The blank node or the IRI that represents node label</li>
                  <li>`pvar:label`: The label as a string literal</li>
                </ul>
              </li>
              <li>
                <dfn data-lt="prec:nodeLabelIRI">http://bruy.at/prec#nodeLabelIRI</dfn>:
                The [= prec:SubstitutionPredicate =] for `pvar:nodeLabelIRI`
              </li>
              <li>
                <dfn data-lt="prec:NodeLabelsTypeOfLabelIRI">http://bruy.at/prec#NodeLabelsTypeOfLabelIRI</dfn>:
                The PREC-0 representation of node labels. Composed of the
                triple `pvar:node rdf:type pvar:nodeLabelIRI`
              </li>
              <li>
                <dfn data-lt="prec:NodeLabelRule">http://bruy.at/prec#NodeLabelRule</dfn>:
                The type of rules that applies to node / node label pairs.
              </li>
              <li>
                <dfn data-lt="prec:label (node label rule)">http://bruy.at/prec#label (in node label rules)</dfn>:
                Condition on the label of the node. Mandatory.
              </li>
              <li>
                <dfn data-lt="prec:NodeLabels">http://bruy.at/prec#NodeLabels</dfn>:
                The domain of every node labels, to modify the template used.
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h4><dfn data-lt="prec:mapBlankNodesToPrefix">http://bruy.at/prec#mapBlankNodesToPrefix</dfn></h4>
          
          <p>
            The graph generated by [= PREC-0 =] uses blank nodes for everything
            that is not a label or a value. The user may prefer to have IRIs
            generated for the different part of the vocabulary. For example,
            instead of generating a blank node for the label "Person", the user
            may prefer to get `http://example.org/Person`.
          </p>

          <p>
            [= prec:mapBlankNodesToPrefix =] enables to map
            <ul>
              <li>every node label if the subject is pgo:Node</li>
              <li>every edge label if the subject is pgo:Edge</li>
              <li>every property name if the subject is [= prec:PropertyKey =]</li>
            </ul>
            to IRis that starts with the prefix specfied in object position.
          </p>

          <aside class="warning">
            <p>
              The author of the ontology recognizes that using pgo:Node
              and pgo:Edge for the group of every node label and every
              edge label was a terrible idea. The expected subjects
              of [= prec:mapBlankNodesToPrefix =] are subject to change.
            </p>
          </aside>

          <aside class="example">
            <p>
              Given the following Property Graph
            </p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person :Animal ]
              -->
            </pre>
            <p>And the following context:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              pgo:Node prec:mapBlankNodesToPrefix <http://example.org#>.
              -->
            </pre>
            <p>The generated graph will be of the form:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node a pgo:Node ,
                       http://example.org#something1 ,
                       http://example.org#something2 .
              
              # The suffix can be anything
              http://example.org#something1 rdfs:label "Person" .
              http://example.org#something2 rdfs:label "Animal" .
              -->
            </pre>
          </aside>
        </section>

      </section>
      
      <section>
        <h3>Substitutions</h3>

        <p>
          Most rules actually use alterations of templates. For example, in
          [= prec:EdgeRule =]s, most of the time the
          `pvar:edgeIRI` variable will be replaced by an IRI picked by
          the user thanks to [= prec:edgeIRI =].
        </p>

        <p>
          The reason why [= prec:edgeIRI =] can modify the template is
          because it is defined as a [= prec:SubstitutionPredicate =] for
          `pvar:edgeIRI`: when used in a rule,
          [= prec:edgeIRI =] will look for every `pvar:edgeIRI`
          occurrence, and replace it with something else.
        </p>

        <section>
          <h4><dfn data-lt="prec:SubstitutionPredicate">http://bruy.at/prec#SubstitutionPredicate</dfn></h4>

          <p>
            The type of substitution terms. To be effective, a
            [= prec:SubstitutionPredicate =] should have a value for
            [= prec:substitutionTarget =].
          </p>
        </section>

        <section>
          <h4><dfn data-lt="prec:substitutionTarget">http://bruy.at/prec#substitutionTarget</dfn></h4>

          <p>
            States the term that is looked for in the template on which the
            substitution term applies.
          </p>
          
          <aside class="example">
            <p>`prec:subject` is a substitution term for `rdf:subject`.</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:subject a prec:SubstitutionPredicate ;
                prec:substitutionTarget rdf:subject.
              -->
            </pre>

            <p>
              When `prec:subject` is used on a rule, it will replace
              `rdf:subject` with something else. Similar directives exist
              for `prec:predicate` and `prec:object`.
            </p>
          </aside>

          <aside class="example">
            <p>
              Let us consider we have the following property graph. Values
              inside parenthesis are not actual values, and are solely for
              clarity. In this graph, we have two nodes, and an edge
              from one to another with the label `like`.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
                        (edge):like
              [(alice)] ------------ > [(bob)]
              -->
            </pre>

            <p>
              [= PREC-0 =] translates this property graph into an RDF graph
              isomorphic to the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:alice a pgo:Node .
              _:bob   a pgo:Node .
              _:edge  a pgo:Edge ;
                rdf:subject _:alice ;
                rdf:predicate [ rdfs:label "like" ] ;
                rdf:object  _: bob .
              -->
            </pre>

            <p>
              If we apply the following context with [= PREC-Context =], we will
              obtain the following RDF Data graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # Context
              prec:Edges prec:templatedBy prec:RDFReificaiton ;
                prec:subject <https://example.org/user> ;
                prec:predicate rdf:type ;
                prec:object <https://example.org/influencer> .
              -->
            </pre>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # RDF Data Graph
              _:edge a pgo:Edge ;
                <https://example.org/user> _:alice ;
                rdf:type [ rdfs:label "like" ] ;
                <https://example.org/influencer> _:bob .
              
              _alice a pgo:Node .
              _:bob  a pgo:Node .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4>Substitution terms defined in every context</h4>

          <p>
            The following substitution terms are defined for every context by
            [= PREC-Context =]:
            <ul>
              <li>`prec:subject`: Substitution term for `rdf:subject`.</li>
              <li>`prec:predicate`: Substitution term for `rdf:predicate`.</li>
              <li>`prec:object`: Substitution term for `rdf:object`.</li>
              <li>`prec:edgeIRI`: Substitution term for `pvar:edgeIRI`. Expected to be used in most [= prec:EdgeRule =]s.</li>
              <li>`prec:propertyIRI`: Substitution term for `pvar:propertyIRI`. Expected to be used in most [= prec:PropertyRule =].</li>
            </ul>
          </p>

          <p>
            `prec:subject`, `prec:predicate`, `prec:object` are defined to
            represent an edge as a fully fledge object. They let the user
            rename more accurate terms than the "RDF grounded terms". This is
            inspired by http://www.bobdc.com/blog/reification-is-a-red-herring/.
          </p>
        </section>
      </section>
    </section>

    </section>

    <section class="informative">
      <h2>Test infrastructure</h2>

      <p>
      Used in `./test/prec/*.ttl` files, which are used for unit tests. These files
      are inputs for `./z_prec.js`.
      </p>
      
      
      <p>Each unit test contains:
        <ul>
        <li>where are the inputs by using `prec:testMetaData` as a subject</li>
        <li>the expected triples generated by PREC. Blank nodes are used as wildcards.</li>
        </ul>
      </p>
      
      <h3>Used IRIs</h3>

      <ul>
        <li>
          <dfn class="lint-ignore">http://bruy.at/prec#UnitTest</dfn>:
          Type of a single unit test
        </li>
        <li>
          <dfn class="lint-ignore">http://bruy.at/prec#relativePath</dfn>:
          Datatype used when the input / context is not the string itself but
          located in the file described by the literal.
        </li>
        <li>
          <dfn class="lint-ignore">http://bruy.at/prec#context</dfn>:
          `prec:context` states what is the content of the context.
          <br>
          `_:someTest prec:context _:context` means that the unit test
          `_:someTest` uses the content of the graph `_:context` as the context.
        </li>
        <li>
          <dfn class="lint-ignore">http://bruy.at/prec#output</dfn>:
          `prec:output` states what is the expected output.
          <br>
          `_:someTest prec:output _:output` means that the unit test
          `_:someTest` expects the content of the named graph `_:output` as the
          output of PREC.
        </li>
        <li>
          <dfn class="lint-ignore">http://bruy.at/prec#propertyGraph</dfn>:
          `prec:propertyGraph` states the content of the property graph as a
          string in the JSON APOC export format.
      </ul>
    </section>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PREC</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "unofficial",
        editors: [
            {
                name: "Julian Bruyat",
                url: "https://bruy.at",
                company: "LIRIS - INSA Lyon",
                companyURL: "https://liris.cnrs.fr"
            }
        ],
        github: "https://github.com/BruJu/PREC/",
        xref: "web-platform",
        format: "markdown"
      };
    </script>
    
      <script>
        /* copied from JSON-LD specs */
        function updateExample(doc, content) {
          // perform transformations to make it render and prettier
          return _esc(reindent(unComment(doc, content)));
        }
    
        function _esc(s) {
          return s.replace(/&/g,'&amp;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/</g,'&lt;');
        }
    
        function reindent(text) {
          // TODO: use trimEnd when Edge supports it
          const lines = text.trimRight().split("\n");
          while (lines.length && !lines[0].trim()) {
            lines.shift();
          }
          const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
          const leastIndent = Math.min(...indents);
          return lines.map(s => s.slice(leastIndent)).join("\n");
        }
    
        function unComment(doc, content) {
          // perform transformations to make it render and prettier
          return content
            .replace(/<!--/, '')
            .replace(/-->/, '')
            .replace(/< !\s*-\s*-/g, '<!--')
            .replace(/-\s*- >/g, '-->')
            .replace(/-\s*-\s*&gt;/g, '--&gt;');
        }
      </script>
  </head>
  <body>
    <h2 id="subtitle">Property Graph - RDF Experimental Converter</h2>
    <section id="abstract">
      <p>PREC is a library designed to enable interoperability between RDF graphs
        and property graphs.</p>

      <p>This document mainly describes the PREC ontology: an ontology designed
        to describes the binding between the terms used in an RDF graph and the
        labels used in a property graph.</p>
    </section>
    <section>
      <h2>Introduction</h2>

      <p><a href="https://github.com/BruJu/PREC/">PREC</a> is composed of two modules:</p>
      <ul>
        <li><dfn>PREC-0</dfn>, a Property Graph to RDF graph converter</li>
        <li><dfn>PRSC</dfn> (PG to RDF, Schema-based Converter), an RDF Graph generated from PREC-0 to more readable graphs converter, based on schemas</li>
        <li><dfn>PREC-C</dfn> (PREC-Context), an RDF Graph generated from PREC-0 to more readable graphs converter</li>
      </ul>
      
      <p>To define the transformations to apply, PRSC and PREC-Context uses a <em>Context</em> provided
      by the user in <a href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html#turtle-star">Turtle-Star</a> format.
      </p>

      <aside class="warning" title="(Un)stability of the ontology">
        <p>This ontology is currently very tentative and is subject to change.</p>
      </aside>

      <aside class="note" title="Terminology">
        <p>
          The following terms are used to describe Property Graphs:
          <ul>
            <li><em>Node</em>, sometimes called <em>Vertex</em> in other works.</li>
            <li><em>Edge</em>, sometimes called <em>Relationship</em> in other works.</li>
            <li><em>Element</em>, something that is either a node or an edge.</li>
            <li>
              <em>Source node</em>, the node from which an edge starts.
              Sometimes called <em>start node</em> in other works.
            </li>
            <li>
              <em>Destination node</em>, the node from which an edge ends.
              Sometimes called <em>end node</em> or <em>target node</em> in
              other works.
            </li>
          </ul>
      </aside>

      <section>
        <h3>Schema of the PREC-0 graphs</h3>
        <p>
          The current schema of PREC-0 graphs is as follows:<br>
          <img src="prec0schema.png" alt="The schema of PREC-0 graphs" style="width: 100%; height: auto;"/>
        </p>
        <p>
          A partial SHACL Shapes Graph is available at
          <a href="https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl">
            https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl
          </a>. This SHACL Shapes Graph should be conform on every PREC-0
          generated graph (graphs extracted by PREC without any context).
        </p>
      </section>

      <section>
        <h3>Use of a context</h3>

        <p>The context can be automatically applied during the convertion of the Property Graph to RDF:</p>
        <ul>
          <li>For example, for a Neo4j graph for which you have already extacted
            the content in Json format with the APOC extension, use
            `prec apoc2rdf path_to_property_graph_content.json -c path_to_context.ttl`
          </li>
        </ul>
      
        <p>If you have already generated the PREC-0 graph, you can use the ApplyContext tool:</p>
        <ul>
          <li>`prec applyContext path_to_prec0_graph.ttl path_to_context.ttl`</li>
        </ul>

      </section>

      <section>
        <h3>Example of a context</h3>

        <aside class="example">
          <p>
            In this section, we will present the ontology through a practical
            example. Considering a property graph with the following data
            (exposed in a format similar to a Cypher query):
          </p>

          <pre>
            ( haddock   :Person { name: "Haddock", firstName: "Archibald" } ),
            ( snowy     :Animal { name: "Snowy"  } ),
            ( the_serie :Serie  { name: "The Adventures of Tintin" } ),

            ( haddock ) -[ :appears { since: "The Crab with the Golden Claws"   } ]->( the_serie ),
            ( snowy   ) -[ :appears { since: "Tintin in the Land of the Soviets" }]->( the_serie ),
            ( haddock ) -[ :knows ]->( snowy )
          </pre>

          <p>
            PREC enables us to convert this Property Graph into an RDF graph.
            The graph generated without any context is very verbose, and will
            not be displayed here. Instead, we are going to write a context to
            produce a small and readable graph.
          </p>

          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
              @prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
              @prefix prec: <http://bruy.at/prec#> .
              @prefix pvar: <http://bruy.at/prec-trans#> .
              @prefix pgo:  <http://ii.uwb.edu.pl/pgo#> .

              # We want properties to be written in the RDF-graph as
              # [the node or edge] [iri of the property] [the value]
              prec:Properties prec:templatedBy prec:DirectTriples .

              # We want edges to be written in the RDF-graph as
              # [the source] [the label] [the destination]
              # and use RDF-star for properties
              prec:Edges prec:templatedBy prec:RdfStarUnique .

              # == Properties

              # The name of a person is its family name
              [] a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/familyName> ;
                prec:label "Person" ; prec:onKind prec:Node .
              
              [] a prec:PropertyRule ;
                prec:propertyKey "firstName" ;
                prec:propertyIRI <http://schema.org/givenName> .

              # Other names are names
              [] a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/name> .
              
              # We use an IRI from dbpedia for the since property
              # As writing rules for simple things is very long, we are
              # going to use a syntactic sugar
              <http://dbpedia.org/property/debut> prec:IRIOfProperty "since" .

              # == Node labels
              <http://dbpedia.org/resource/Person> prec:IRIOfNodeLabel "Person" .
              <http://dbpedia.org/resource/Animal> prec:IRIOfNodeLabel "Animal" .
              <http://dbpedia.org/class/yago/Series108457976> prec:IRIOfNodeLabel "Serie" .

              # == Edges
              <http://schema.org/knowsAbout> prec:IRIOfEdgeLabel "knows" .
              <http://schema.org/knowsAbout> prec:IRIOfEdgeLabel "knows" .

              # Map appears to schema:character. One problem of schema:character
              # is that is expect the serie as the subject and the character as
              # an object, but we can fix the order!
              [] a prec:EdgeRule ;
                prec:label "appears" ;
                # We want the destination to be the source and the destination
                # to be the source so let's write our own template!
                prec:templatedBy [
                  a prec:EdgeTemplate ;
                  prec:produces
                    # Assert the triple
                    <<    pvar:destination pvar:edgeIRI pvar:source               >> ,
                    # Keep the provenance
                    << << pvar:destination pvar:edgeIRI pvar:source >> a pgo:Edge >>
                ] ;
                # Properties will use the following term as their subject
                prec:edgeIs << pvar:destination pvar:edgeIRI pvar:source >> ;
                # prec:edgeIRI will actually replace pvar:edge with schema:character
                prec:edgeIRI <http://schema.org/character> .
            -->
          </pre>

          <p>
            The produce RDF-graph will be isomorphic to be following:
          </p>

          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
            # Note that Haddock have no http://schema.org/name
            _:haddock a pgo:Node, <http://dbpedia.org/resource/Person>;
                <http://schema.org/givenName> "Archibald";
                <http://schema.org/familyName> "Haddock".
            
            _:snowy a pgo:Node, <http://dbpedia.org/resource/Animal>;
                <http://schema.org/name> "Snowy".
            
            _:adventures_of_tintin a pgo:Node, <http://dbpedia.org/class/yago/Series108457976>;
                <http://schema.org/name> "The Adventures of Tintin";
                # The edge have been properly inverted
                <http://schema.org/character> _:haddock, _:snowy.     

            _:haddock <http://schema.org/knowsAbout> _:snowy.
            <<_:haddock <http://schema.org/knowsAbout> _:snowy>> a pgo:Edge.
              
            # When did every character appear?
            <<_:adventures_of_tintin <http://schema.org/character> _:haddock>> a pgo:Edge;
                <http://dbpedia.org/property/debut> "The Crab with the Golden Claws".

            <<_:adventures_of_tintin <http://schema.org/character> _:snowy>> a pgo:Edge;
                <http://dbpedia.org/property/debut> "Tintin in the Land of the Soviets".
            -->
          </pre>

          <p>
            Note that in this example, while the produced output is easy to
            read and reuse existing ontologies, we are not conforming to the DBPedia
            usual schema, as in DBpedia, `<http://dbpedia.org/property/debut>`
            would be used with the character as the subject and the book (and
            not its name) as the object ; and in the current state of the
            ontology we can not do better. This is one of the weakness of
            the ontology: it can not conform to every schema.
          </p>
        </aside>
      </section>
    </section>

    <section>
      <h2>The PREC ontology</h2>


      <section>
        <h2>PRSC - Schema driven mapping</h3>

          <p>
            PRSC contexts are contexts that transform all nodes and edges that
            share a common type by using a given RDF representation.
            A type is defined as whenever the element is an edge or a node,
            the list of labels and the list of properties of the element.
          </p>
  
  
        <p>
          This kind of context identify every node and edges to a schema, and the
          transformation of every schema from PG to RDF must be defined.
        </p>
  
          <!--
        <p>
          This is heavily inspired from the presentation of the
          <em>Property Graph Schema Working Group</em> at 
          <em>the 1st workshop on Squaring the circle on graphs</em>.
        </p>
      -->
  
        <strong>List of valid IRIS for a PRSC rule are:</strong>
        <ul>
          <li>`prec:PRSCNodeRule` - Type for rules that target nodes</li>
          <li>`prec:PRSCEdgeRule` - Type for rules that target edges.</li>
          <li>`prec:label` - A label the node must have</li>
          <li>`prec:propertyKey` - A property the node must have</li>
          <li>`prec:produces` - describes how to represent the elements that complies to the rule</li>
        </ul>
  
        <strong>Placeholders for the template part (objects of prec:produces)</strong>
        <ul>
          <li>`pvar:self` - The identifier for the element (node or edge)</li>
          <li>`pvar:source` - Edges only, source of the edge</li>
          <li>`pvar:destination` - Edges only, destination of the edge</li>
          <li>`"property key"^^prec:valueOf` - Placeholder for the value of the property "property name"</li>
        </ul>
  
        
        <aside class="example" title="Example of a PRSC context">
  
          <p>
            After cloning the repo, test it by running
            `npx ts-node apoc2rdf prec.ts data\ex2_annlikesdan1.json -c data\ex2_anndan_prsc.ttl`
          </p>
          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
              PREFIX prec: <http://bruy.at/prec#>
              PREFIX pvar: <http://bruy.at/prec-trans#>
              PREFIX ex:   <http://example.org/>
              PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
  
              ex:PersonForm a prec:PRSCNodeRule ;
                prec:label "Person" ;
                prec:propertyKey "name" ;
                prec:produces
                  << pvar:node ex:hasLabel ex:person >> ,
                  << pvar:node ex:name "name"^^prec:valueOf >> .
  
              ex:LovesForm a prec:PRSCEdgeRule ;
                prec:label "Likes" ;
                prec:produces << pvar:source ex:loves pvar:destination >> .
            -->
          </pre>
  
        </aside>
      </section>
  

      
        <p>
          Unlike PRSC context that only have rules for nodes and edges, PREC-C
          context ruleset can target node, edges and properties.
        </p>

      <section>
        <h3>Types</h3>

        <p>
          The PREC ontology introduces some new types for the graphs generated
          by PREC-0. Note that the
          <a href="http://ii.uwb.edu.pl/pgo#Node">pgo:Node</a>
          and the 
          <a href="http://ii.uwb.edu.pl/pgo#Edge">pgo:Edge</a>
          types are used in the graphs generated by PREC-0.
        </p>

        <section>
          <h4><dfn data-lt="prec:CreatedVocabulary">http://bruy.at/prec#CreatedVocabulary</dfn></h4>
          
          <p>Type of IRIs that has been created by PREC and that
          should be mapped to an actual ontology.</p>

          <p>Types that are subtypes of [= prec:CreatedVocabulary =] are:
            <ul>
              <li><dfn data-lt="prec:CreatedPropertyKey">http://bruy.at/prec#CreatedPropertyKey</dfn></li>
              <li><dfn data-lt="prec:CreatedNodeLabel">http://bruy.at/prec#CreatedNodeLabel</dfn></li>
              <li><dfn data-lt="prec:CreatedEdgeLabel">http://bruy.at/prec#CreatedEdgeLabel</dfn></li>
            </ul>
          </p>


        </section>

        <section>
          <h4><dfn data-lt="prec:PropertyKey">http://bruy.at/prec#PropertyKey</dfn></h4>

          <p>Type of property keys.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#PropertyKeyValue</h4>

          <p>Type of property values. Can be seed as the counterpart of
          <a href="http://ii.uwb.edu.pl/pgo#Property">pgo:Property</a> in the
          PREC-0 modelization.</p>
        </section>
        
        <section>
          <h4><dfn data-lt="prec:hasMetaProperties">http://bruy.at/prec#hasMetaProperties</dfn></h4>

          <p>States to which (RDF) node the meta properties of a property are
            attached to.</p>

            <aside class="example">
              <p>Bob lives in Paris and is a tenant of his appartment.</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:bob :live_in [
                    rdf:type prec:PropertyKeyValue ;
                    rdf:value "Paris" ;
                    prec:hasMetaProperties [
                        :status [ rdf:value "Tenant" ; rdf:type prec:PropertyKeyValue ]
                    ]
                ] .
                
                :live_in a prec:PropertyKey .
                :status  a prec:PropertyKey .
                -->
              </pre>
            </aside>
        </section>
      </section>

      
      <section>
        <h3>Reserved IRIs</h4>

        <p>IRIs in the `prec` namespace are reserved for the ontology.</p>

        <p><a href="https://github.com/BruJu/PREC/">The default implementation</a>
          reserves for itself the IRIs prefixed with `_` and `__`. Therefore,
          as they are reserved for implementation, using them in a context
          results in undefined behaviour.</p>
      </section>

      <section>
        <h3>General directives</h3>

        <section>
          <h4><dfn data-lt="prec:KeepProvenance">http://bruy.at/prec#KeepProvenance</dfn></h4>

          <p>
            By default, a triple is created for each node / edge /
            property label / property blank node between its IRI / blank node
            and the corresponding type.
          <br>If this flag is set to `false`, the triples in the form
            `ex:node1 a pgo:Node` are deleted from the output graph.</p>

          <aside class="example">
            <p>Keep the types (default behaviour).</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState true .
              -->
            </pre>

            <p>Remove the types.</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState false .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4>http://bruy.at/prec#flagState</h4>

          <p>Used as the predicate of [= prec:KeepProvenance =].</p>
        </section>
      </section>

      <section>
        <h3>Change the schema of the generated graph</h3>

        <p>[= PREC-0 =] generates an RDF Graph with a certain format. It is
          possible to change the way the properties and the edges are
          represented in the RDF graph.</p>

        <p>By default:</p>
        <ul>
          <li>Edges are materialized using a standard RDF Reification</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:theEdge a pgo:Edge ;
              rdf:subject _:sourceNode ;
              rdf:predicate [ rdfs:label "TheLabel" ] ;
              rdf:object _:targetNode .
            -->
          </pre>
          <li>Properties are materialized like in the following example:</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:eitherTheNodeOrTheEdge :propertyKey _:aBlankNode .
            _:aBlankNode rdf:value "The value of the property" .
            _:aBlankNode prec:hasMetaProperties _:aNodeWithTheMetaPropertiesIfAny .
            
            :propertyKey a prec:PropertyKey ; rdfs:label "The name of the property" .
            _:aBlankNode a prec:PropertyKeyValue .
            -->
          </pre>
        </ul>

        <p>[= PREC-Context =] is able to change the format used to represent the
          properties and the edges by using templates.
          <br>In PREC, we call a <em>template</em> the format wanted by the user.</p>

          <section>
            <h4><dfn data-lt="prec:templatedBy">http://bruy.at/prec#templatedBy</dfn></h4>

            <p>
              Predicate used to state that the components affected by the
              subject rule must be represented in the format described in the
              object.
            </p>

              <aside class="example">
                <p>
                  A context that requires every edge to be represented
                  with the Singleton Property pattern.
                </p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  PREFIX prec: <http://bruy.at/prec#>
                  prec:Edges prec:templatedBy prec:SingletonProperty .
                  -->
                </pre>
              </aside>

          </section>

        <section>
          <h4>Edge templates</h4>

          <p>
            [= PREC-Context =] uses a special IRI for the set of every
            edges and defines some base templates that are implcitely
            defined in every context.
          </p>

          <p>Thanks to these IRIs and [= prec:templatedBy =], it is possible to
            tranform the representation used for every edge from the standard
            RDF Reification to any template.
          </p>
          
          <section>
            <h5><dfn data-lt="prec:Edges">http://bruy.at/prec#Edges</dfn></h5>

            <p>
              [= prec:Edges =] is the domain of every edge. A template that is
              applied to this IRI will be applied to every edge.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RDFReification">http://bruy.at/prec#RDFReification</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RDFReification .`
              <br />Edges must be represented by using the standard RDF
              Reification. This is the default behaviour.
            </p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarUnique">http://bruy.at/prec#RdfStarUnique</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RdfStarUnique .`
              <br>Edges are modeled as a triple that is added to th
               graph, and meta properties are added using RDF-star. This
               templatewill cause information loss if there are two edges with
               the same label between two nodes.
            </p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarOccurrence">http://bruy.at/prec#RDFStarOccurrence</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:RDFStarOccurrence .`
              <br>Edges are modeled as an RDF-star occurence: a blank
              node represents the occurrence and [= prec:occurrenceOf =] is used
              to link the node to the triple it is an occurence of.
            </p>

            <section>
              <h5><dfn data-lt="prec:occurrenceOf">http://bruy.at/prec#occurrenceOf</dfn></h5>

              <p><em>
                This IRI is used in the generated graphs and should not be used
                in contexts as a "keyword".
              </em></p>

              <p>
                Specifies for which triple the edge is an occurrenceOf.
                The semantics is identic to the one used in the
                <a href="https://w3c.github.io/rdf-star/cg-spec/2021-04-13.html#occurrences">
                  latest RDF-star draft
                </a>.
              </p>

              <aside class="example">
                <p>
                  Joe Biden "worked" for the White House from 2009 to 2017 as
                  the vice president and since 2021 as the president.
                </p>
                

                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  _:first  prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  _:second prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  
                  _:first  :from 2009; :to 2017 ; :role "Vice President" .
                  _:second :from 2021;            :role "President"      .
                  -->
                </pre>

                <p><em>Why do we need this?</em></p>
                
                <p>If we write</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >> :from 2009; :to 2017 ; :role "Vice President" .
                  << :joe_biden :workingFor :white_house >> :from 2021;            :role "President"      .
                  -->
                </pre>
                
                <p>it is equivalent to writing</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >>
                    :from 2009, 2021 ;
                    :to 2017 ;
                    :role "Vice President", "President" .
                  -->
                </pre>
                
                <p>
                  While we can deduce from the semantic of `:from`, `:to` and
                  years that Joe Biden worked from 2009 to 2017 then from 2021
                  for the White House, and while we know that he worked as the
                  Vice President and the President, we are unable to distinguish
                  when he was Vice President and when he was President.
                </p>
              </aside>
            </section>
          </section>
          <section>
            <h5><dfn data-lt="prec:SingletonProperty">http://bruy.at/prec#SingletonProperty</dfn></h5>
            <p>
              `prec:Edges prec:templatedBy prec:SingletonProperty .`
              <br>Edges must be represented by using singleton properties.
            </p>
          </section>
        </section>

        <section>
          <h4>Property templates</h4>

          <p>The template used for properties can also be redefined.</p>

          <section>
            <h5><dfn data-lt="prec:Properties">http://bruy.at/prec#Properties</dfn></h5>

            <p>
              The domain of every properties. A triple that has
              [= prec:Properties =] as a subject is equivalent to three triples,
              one with [= prec:NodeProperties =] as the subject, another with
              [= prec:EdgeProperties =] as the subject and another
              with [= prec:MetaProperties =] as the subject.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:NodeProperties">http://bruy.at/prec#NodeProperties</dfn></h5>

            <p>The domain of every node properties. The properties on
              edges will not be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeProperties">http://bruy.at/prec#EdgeProperties</dfn></h5>

            <p>The domain of every edge properties. The properties on
              nodes will not be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:MetaProperties">http://bruy.at/prec#MetaProperties</dfn></h5>

            <p>
              The domain of every meta properties (properties on properties).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:Prec0Property">http://bruy.at/prec#Prec0Property</dfn></h5>

            <p>
              Properties are modeled in the format presented in the
              [= prec:hasMetaProperties =] example. This is the default
              behaviour.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:CombinedBlankNodes">http://bruy.at/prec#CombinedBlankNodes</dfn></h5>

            <p>
              Properties are modeled in the same format as
              [= prec:Prec0Property =], but the `propertyValue` and the
              `metaProperty` nodes are merged.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:DirectTriples">http://bruy.at/prec#DirectTriples</dfn></h5>

            <p>
              Properties are modeled without any blank node
              (`:node :propertyKey :thePropertyValueLiteral`), and the meta
              properties are represented by using RDF-star.
            </p>
          </section>
        </section>

        <section>
          <h4>Writting your own templates</h4>

          <p>
            So far, this document described how to use predefined templates. It
            is also possible to write you own templates.
          </p>

          <p>
            Templates uses the `pvar` namespace (http://bruy.at/prec-trans#) as
            variable/placeholders. pvar can be seen as a way to write `?` in a
            Turtle file without actually using a real variable.
          </p>

          <aside class="note">
            <p>
              Every built-in template is actually defined in a turtle file that
              is loaded and included to every context you write.
            </p>
          </aside>

          <section>
            <h5><dfn data-lt="prec:produces">http://bruy.at/prec#produces</dfn></h5>

            <p>
              Used to state the list of RDF triples that composes the template.
              When the template is applied, every triple used in the default
              PREC-0 representation will be replaced with the triples that
              composes the template (after replacing the placeholders with
              their actual value).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeTemplate">http://bruy.at/prec#EdgeTemplate</dfn></h5>

            <p>The type of templates that can be used for edges.</p>

            <p>`EdgeTemplate`s use the following variable:</p>
            <ul>
              <li>`pvar:edge`: The RDF node that was created to identify the edge.</li>
              <li>`pvar:source`: The RDF node that represents the PG source node of the edge.</li>
              <li>`pvar:destination`: The RDF node that represents the PG destination edge.</li>
              <li>`pvar:edgeIRI`: The RDF node that represents the label of the edge.</li>
              <li>`pvar:label`: The label of the edge, as a string literal.</li>
              <li>`prec:edgeIs`: enables to specify to which term bind the properties of the edge.</li>
            </ul>

            <p>
              We are going to show how a user can define its own template

            <aside class="example">
              <p>An [= prec:EdgeTemplate =] that is the identity / the standard RDF Reification</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RDFReification a prec:EdgeTemplate ;
                  prec:produces
                    << pvar:edge a pgo:Edge >> ,
                    << pvar:edge rdf:subject      pvar:source          >> ,
                    << pvar:edge rdf:predicate    pvar:edgeIRI >> ,
                    << pvar:edge rdf:object       pvar:destination     >> ;
                  prec:edgeIs pvar:edge
                .
                -->
              </pre>

              <p>
                Note that `prec:RDFReification` is the pattern that is matched
                against, which means templating an edge with the
                `prec:RDFReification` will result in the same graph.
              </p>
            </aside>

            <aside class="example">
              <p>
                [= prec:RDFStarUnique =] is a template that assumes that every
                edges between the same two nodes have a different label.
              </p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RdfStarUnique a prec:EdgeTemplate ;
                  prec:produces
                    <<    pvar:source pvar:edgeIRI pvar:destination               >> , # (a)
                    << << pvar:source pvar:edgeIRI pvar:destination >> a pgo:Edge >> ; # (b)
                  prec:edgeIs
                    << pvar:source pvar:edgeIRI pvar:destination >> .                  # (c)
                .
                -->
              </pre>

              <p>If we suppose we have the following RDF Graph:</p>
              
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:edge1 a pgo:Edge ;
                  rdf:subject _:src ;
                  rdf:predicate _:label ;
                  rdf:object _:dest ;
                  _:propPlace _:propValuePlace ;
                  _:propTime  _:propValueTime .
                -->
              </pre>

              <p>The variables will match as follow:</p>

              <table>
                <tr><th>Variable name</th>                 <th>Value</th>               </tr>
                <tr><td> `pvar:edge`                  </td><td> `_:edge1`          </td></tr>
                <tr><td> `pvar:source`                </td><td> `_:src`            </td></tr>
                <tr><td> `pvar:destination`           </td><td> `_:dest`           </td></tr>
                <tr><td> `pvar:edgeIRI        `       </td><td> `_:label`          </td></tr>
              </table>

              <p>The triples `_:edge1 _:propPlace _:propValuePlace (1)` and 
              `_:edge1 _:propTime  _:propValueTime (2)` are related to
              properties.</p>
              
              <p>The produced graph will be the following:</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:src _:label _:dest .                  # From (a)
                << _:src _:label _:dest >> a pgo:Edge . # From (b)
                << _:src _:label _:dest >> _:propPlace _:propValuePlace . # From (c) using (1)
                << _:src _:label _:dest >> _:propTime  _:propValueTime  . # From (c) using (2)
                -->
              </pre>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:PropertyTemplate">http://bruy.at/prec#PropertyTemplate</dfn></h5>

            <p>The type of templates that can be used for properties.</p>
            
            <p>`prec:PropertyTemplate`s use the following variables:</p>
            <ul>
              <li>`pvar:entity`: The RDF node that was created to identify the edge of the node.</li>
              <li>`pvar:propertyKey`: The node that represents the edge label.</li>
              <li>`pvar:label`: The label of the property key, as a string literal.</li>
              <li>`pvar:property`: The blank node that represents the property.</li>
              <li>`pvar:propertyValue`: The literal that contains the property value.</li>
              <li>`pvar:individualValue`: Most of the time equals to `propertyValue`. If `propertyValue` is an rdf list, `individualValue` will match each individual literal contained in the list instead of the list itself.</li>
              <li>`pvar:metaPropertyNode`: The blank node that contains every meta property, as described in [= prec:hasMetaProperties =]</li>
              <li>`prec:entityIs`: The term to which the meta properties must be bound.</li>
            </ul>

            <p>
              The substitution mecanism is the same as described in the
              [= prec:EdgeTemplate =] section.
            </p>

            <p>Some restrictions exists on property templates:
              <ul>
                <li>
                  `pvar:entity` can only appear in the "subject-star" position.
                  The `subject-star` position is defined recursively as either
                  the subject of the quad if it is not a nested quad, or the
                  "subject-star" of the quad in the subject position. In other
                  words, when the Triple-star is written in the N-Triples-star
                  format, it is the first non RDF-star term that appears for
                  this triple.
                </li>
                <li>
                  Every embedded triple must be asserted by the template.
                </li>
              </ul>
            </p>
            <p>
              These restriction exists to make combinations between an
              edge template and different (meta)-property templates
              possible. These restrictions will be attenuated in the future.
            </p>
          </section>
        </section>

      <section>
        <h3>Rules</h3>

        <p>
          Rules are the main way to modify a [= PREC-0 =] RDF graph. They let
          the user modify specific elements of the graphs by:
          <ul>
            <li>filtering some of the edges or properties</li>
            <li>applying a specific template to these entities</li>
          </ul>
        </p>

        <p>
          As one can expect, there are two different kind of rules : rules for
          edges ([= prec:EdgeRule =]) and rules for properties
          ([= prec:PropertyRule =]).
        </p>

        <section>
          <h4>Edge rules</h4>

          <p>
            Edge rules aim to modify the way the property graph
            edges are materialized in the RDF Graph.
          </p>

          <aside class="example">
            <p>
              A rule that only applies to edges with the label "Like"
              and for which both the source and the destination node have the
              label "Person". This rule will materialize these edge
              as a standard RDF Triple, with `ex:like` as the predicate
              (for example `:alice ex:like :bob` will be produced).
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [] a prec:EdgeRule ;
                # - Filtering
                # Like must be the edge label
                prec:label "Like" ;
                # The source node must have the label Person
                prec:sourceLabel      "Person" ;
                # The destination node must have the label Person
                prec:destinationLabel "Person" ;
                # - Transformation
                # Replace the generated IRI for the edge label with ex:like
                prec:edgeIRI ex:like ;
                # Modelize this edge by using the prec:RDFStarUnique
                # template instead of a standard RDF Reification
                prec:templatedBy prec:RDFStarUnique .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:EdgeRule">http://bruy.at/prec#EdgeRule</dfn></h5>

            <p>
              The type of edge rules. The [= PREC-Context =] engine
              currently requires the edge rules to be properly typed to
              be able to discover them.
            </p>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:label">http://bruy.at/prec#label</dfn></h5>

            <p>
              States that the edge must have the given label to match
              the rule. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:edgeIRI">http://bruy.at/prec#edgeIRI</dfn></h5>

            <p>
              States that the generated node for the edge must be
              replaced with the given IRI.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:sourceLabel">http://bruy.at/prec#sourceLabel</dfn></h5>

            <p>
              States that the edge source node must have the given
              label. The value must be a literal.
            </p>

            
            <aside class="example">
              <p>
                Let us consider we have the following property graph, with
                three nodes: one of type Person, one of type Cat and one of type
                Food. The Person likes the Cat and the Cat likes the Food.
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                                 (a)                     (b)
                [ :Person ] --- :Like -- > [ :Cat ] --- :Like -- > [ :Food ]
                -->
              </pre>

              <p>
                We can write the following edge rule:
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:Edges prec:templatedBy prec:RDFStarUnique .

                # Matches (a)
                :firstRule a prec:EdgeRule ;
                  prec:label "Like" ;
                  prec:sourceLabel "Person" ;
                  prec:edgeIRI ex:likes .
                
                # Matches (b)
                :secondRule a prec:EdgeRule ;
                  prec:label "Like" ;
                  prec:sourceLabel "Cat" ;
                  prec:edgeIRI ex:eats .
                -->
              </pre>

              <p>The output graph would be the following:</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                # Matches :firstRule, also applies the new default template
                _:person ex:likes _:cat  {| a pgo:Edge |} .
                # Matches :secondRule, also applies the new default template
                _:cat    ex:eats  _:food {| a pgo:Edge |} .

                _:person a pgo:Node, [ rdfs:label "Person" ].
                _:cat    a pgo:Node, [ rdfs:label "Cat"    ].
                _:food   a pgo:Node, [ rdfs:label "Food"   ].
                -->
              </pre>
            </aside>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:destinationLabel">http://bruy.at/prec#destinationLabel</dfn></h5>

            <p>
              Same as [= prec:sourceLabel =], but for the destination node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfEdgeLabel">http://bruy.at/prec#IRIOfEdgeLabel</dfn></h5>

            <p>
              Shortcut to define a edge rule that matches edges
              with a specific label and map the edge label to a specific
              IRI.
            </p>

            <p>The two following contexts are equivalents:

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :iri prec:IRIOfEdgeLabel "Label" .
                -->
              </pre>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:EdgeRule ;
                  prec:label "Label" ;
                  prec:edgeIRI :iri .
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifiying a template</h5>

            <p>
              Like [= prec:Edges =], it is possible to define a target
              template for edge rules by using the [= prec:templatedBy =]
              predicate. It is also possible to apply any
              [= prec:SubstitutionTerm =]s, and not only
              [= prec:edgeIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4>Property rules</h4>

          <p>
            A property rule is a rule that can be applied to a property. In a
            similar fashion as edge rules, a property rule targets some
            properties, and can modify how they are materialized in the graph.
          </p>

          <aside class="example">
            <p>
              Let us consider we have the following property graph, with
              three nodes: one of type Person, one of type Cat and one of type
              Food. The Person likes the Cat and the Cat likes the Food.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person { name: "Macron", givenName: "Emmanuel" }]
                  |
                [ :Owns { since: 2017 } ]
                  |
                 \|/
              [ :Animal { name: "Nemo" }]
              -->
            </pre>

            <p>
              We can use the following context:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:Properties    prec:templatedBy prec:DirectTriples .

              # A rule for the name property of nodes of type Person
              :humanNameRule a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/familyName> ;
                prec:label "Person" .
              
              # A rule for the name property of other things
              :otherNameRule a prec:PropertyRule ;
                prec:propertyKey "name" ;
                prec:propertyIRI <http://schema.org/name> .
              
              # Other rules
              :givenNameRule a prec:PropertyRule ;
                prec:propertyKey "givenName" ;
                prec:propertyIRI <http://schema.org/givenName> .
              
              # The following could have been written
              # [] a prec:PropertyRule ; prec:propertyKey "since" ; prec:propertyIRI :since
              :since prec:IRIOfProperty "since" .
              -->
            </pre>

            <p>The resulting graph would be the (isomorphic to) the following:</p>


            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:macron a pgo:Node, [ rdfs:label "Person" ] .
              _:nemo   a pgo:Node, [ rdfs:label "Animal" ] .

              # Matches :humanNameRule
              _:macron <http://schema.org/familyName> "Macron" .
              # Matches :givenNameRule
              _:macron <http://schema.org/givenName>  "Emmanuel" .

              # Matches :otherNameRule
              _:nemo <http://schema.org/name> "Nemo" .

              # The edge
              _:macronownsnemo a pgo:Edge ;
                rdf:subject   _:macron ;
                rdf:object    _:nemo ;
                rdf:predicate [ rdfs:label "Owns" ] .
              # The property of the edge matches the prec:IRIOfProperty rule
              _:macronownsnemo :since 2017 .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:PropertyRule">http://bruy.at/prec#PropertyRule</dfn></h5>

            <p>
              The type of property rules. The [= PREC-Context =] engine
              currently requires the property rules to be propertly typed to
              be able to discover them.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyKey">http://bruy.at/prec#propertyKey</dfn></h5>

            <p>
              The key / the name of the matched properties. The value must be a
              literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyIRI">http://bruy.at/prec#propertyIRI</dfn></h5>

            <p>
              States the IRI to use for this property name. Its value will be
              used instead of the generated node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:label">http://bruy.at/prec#label</dfn></h5>

            <p>
              States the label that the node or edge must have for the rule to
              apply. If there are several values for [= prec:label =], the node
              must have every labels. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:any">http://bruy.at/prec#onKind</dfn></h5>

            <p>
              The property rule can only be applied if it is a property on a
              node (prec:Node as the object) or an edge (prec:Edge as the
              object).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfProperty">http://bruy.at/prec#IRIOfProperty</dfn></h5>

            <p>
              Enables to declare simple property rules with only one triple,
              instead of three.
            </p>

            <p>The two following rules are equivalent:
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :someIRI prec:IRIOfProperty "APropertyName" .
                -->
              </pre>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:PropertyRule ;
                  prec:propertyKey "APropertyName" ;
                  prec:propertyIRI :someIRI
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifying a template</h5>

            <p>
              Like [= prec:Properties =], [= prec:NodeProperties =] and
              [= prec:EdgeProperties =], it is possible to specify a
              edge for a specific property rule thanks to [= prec:templatedBy =]
              and to use [= prec:SubstitutionTerms =] other than
              [= prec:propertyIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4><dfn data-lt="prec:priority">http://bruy.at/prec#priority</dfn></h4>

          <p>
            By default, [= PREC-Context =] tries to apply rules from the more
            specific to the less specific. While the order of the rules is
            deterministic, the user may prefer to use another.
            [= prec:priority =] enables to change the order of the rules.
          </p>

          <aside class="example">
            <p>
              With this context, thanks to the priority, if an edge
              has a source label that is both an animal and a person, the
              `:personLike` rule is guaranteed to be applied.
            </p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              :personLike a prec:EdgeRule ;
                prec:label "Like" ;
                prec:sourceLabel "Person" ;
                prec:priority 2 ;
                prec:edgeIRI ex:likes .
                
              :catLike a prec:EdgeRule ;
                prec:label "Like" ;
                prec:sourceLabel "Animal" ;
                prec:priority 1 ;
                prec:edgeIRI ex:kind_of_accepts .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4><dfn data-lt="prec:IRIOfNodeLabel">http://bruy.at/prec#IRIOfNodeLabel</dfn></h4>

          <p><em>Usage</em>: ` :IRIToMapTo prec:IRIOfNodeLabel "Label" .`</p>

          <p>
            The last kind of labels that can be remapped are node labels. Node
            labels IRIs can be mapped with [= prec:IRIOfNodeLabel =], in a
            similar fashion as [= prec:IRIOfEdgeLabel =].
          </p>

          <p>
            [= prec:IRIOfNodeLabel =] states that the node labels equals to
            its object (`"Label"`) should be mapped to the IRI stated as the
            subject of the triple (`:IRIToMapTo`), instead of generating /
            keeping a generated a blank node or IRI.
          </p>

          <aside class="example">
            <p>Let us consider the following property graph with two nodes, one
              with the label Person and one with the label Animal:
            </p>
            
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person ]    [ :Animal ]
              -->
            </pre>

            <p>
              [= PREC-0 =] will convert this graph into the following RDF graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node, [ rdfs:label "Person" ] .
              _:node2 a pgo:Node, [ rdfs:label "Animal" ] .
              -->
            </pre>

            <p>Let us consider the following context:</p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              schema:Person prec:IRIOfNodeLabel "Person" .
              schema:Animal prec:IRIOfNodeLabel "Animal" .
              -->
            </pre>

            <p>
              [= PREC-Context =] will transform the [= PREC-0 =] graph into
              the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node, schema:Person .
              _:node2 a pgo:Node, schema:Animal .
              -->
            </pre>
          </aside>

          <section>
            <h5>Complete node rules</h5>

            <p>
              Rules can also be written for node labels. Here is the vocabulary
              related to node labels:
            </p>

            <ul>
              <li><dfn data-lt="prec:NodeLabelTemplate">http://bruy.at/prec#NodeLabelTemplate</dfn>:
                Type of node  templates. The variables that can be used are the
                following:
                <ul>
                  <li>`pvar:node`: The blank node or the IRI that represents PG node</li>
                  <li>`pvar:nodeLabelIRI`: The blank node or the IRI that represents node label</li>
                  <li>`pvar:label`: The label as a string literal</li>
                </ul>
              </li>
              <li>
                <dfn data-lt="prec:nodeLabelIRI">http://bruy.at/prec#nodeLabelIRI</dfn>:
                The [= prec:SubstitutionTerm =] for `pvar:nodeLabelIRI`
              </li>
              <li>
                <dfn data-lt="prec:NodeLabelsTypeOfLabelIRI">http://bruy.at/prec#NodeLabelsTypeOfLabelIRI</dfn>:
                The PREC-0 representation of node labels. Composed of the
                triple `pvar:node rdf:type pvar:nodeLabelIRI`
              </li>
              <li>
                <dfn data-lt="prec:NodeLabelRule">http://bruy.at/prec#NodeLabelRule</dfn>:
                The type of rules that applies to node / node label pairs.
              </li>
              <li>
                <dfn data-lt="prec:label (node label rule)">http://bruy.at/prec#label (in node label rules)</dfn>:
                Condition on the label of the node. Mandatory.
              </li>
              <li>
                <dfn data-lt="prec:NodeLabels">http://bruy.at/prec#NodeLabels</dfn>:
                The domain of every node labels, to modify the template used.
              </li>
            </ul>
          </section>
        </section>

        <section>
          <h4><dfn data-lt="prec:mapBlankNodesToPrefix">http://bruy.at/prec#mapBlankNodesToPrefix</dfn></h4>
          
          <p>
            The graph generated by [= PREC-0 =] uses blank nodes for everything
            that is not a label or a value. The user may prefer to have IRIs
            generated for the different part of the vocabulary. For example,
            instead of generating a blank node for the label "Person", the user
            may prefer to get `http://example.org/Person`.
          </p>

          <p>
            [= prec:mapBlankNodesToPrefix =] enables to map
            <ul>
              <li>every node label if the subject is pgo:Node</li>
              <li>every edge label if the subject is pgo:Edge</li>
              <li>every property name if the subject is [= prec:PropertyKey =]</li>
            </ul>
            to IRis that starts with the prefix specfied in object position.
          </p>

          <aside class="warning">
            <p>
              The author of the ontology recognizes that using pgo:Node
              and pgo:Edge for the group of every node label and every
              edge label was a terrible idea. The expected subjects
              of [= prec:mapBlankNodesToPrefix =] are subject to change.
            </p>
          </aside>

          <aside class="example">
            <p>
              Given the following Property Graph
            </p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person :Animal ]
              -->
            </pre>
            <p>And the following context:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              pgo:Node prec:mapBlankNodesToPrefix <http://example.org#>.
              -->
            </pre>
            <p>The generated graph will be of the form:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node a pgo:Node ,
                       http://example.org#something1 ,
                       http://example.org#something2 .
              
              # The suffix can be anything
              http://example.org#something1 rdfs:label "Person" .
              http://example.org#something2 rdfs:label "Animal" .
              -->
            </pre>
          </aside>
        </section>

      </section>
      
      <section>
        <h3>Substitutions</h3>

        <p>
          Most rules actually use alterations of templates. For example, in
          [= prec:EdgeRule =]s, most of the time the
          `pvar:edgeIRI` variable will be replaced by an IRI picked by
          the user thanks to [= prec:edgeIRI =].
        </p>

        <p>
          The reason why [= prec:edgeIRI =] can modify the template is
          because it is defined as a [= prec:SubstitutionTerm =] for
          `pvar:edgeIRI`: when used in a rule,
          [= prec:edgeIRI =] will look for every `pvar:edgeIRI`
          occurrence, and replace it with something else.
        </p>

        <section>
          <h4><dfn data-lt="prec:SubstitutionTerm">http://bruy.at/prec#SubstitutionTerm</dfn></h4>

          <p>
            The type of substitution terms. To be effective, a
            [= prec:SubstitutionTerm =] should have a value for
            [= prec:substitutionTarget =].
          </p>
        </section>

        <section>
          <h4><dfn data-lt="prec:substitutionTarget">http://bruy.at/prec#substitutionTarget</dfn></h4>

          <p>
            States the term that is looked for in the template on which the
            substitution term applies.
          </p>
          
          <aside class="example">
            <p>`prec:subject` is a substitution term for `rdf:subject`.</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:subject a prec:SubstitutionTerm ;
                prec:substitutionTarget rdf:subject.
              -->
            </pre>

            <p>
              When `prec:subject` is used on a rule, it will replace
              `rdf:subject` with something else. Similar directives exist
              for `prec:predicate` and `prec:object`.
            </p>
          </aside>

          <aside class="example">
            <p>
              Let us consider we have the following property graph. Values
              inside parenthesis are not actual values, and are solely for
              clarity. In this graph, we have two nodes, and an edge
              from one to another with the label `like`.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
                        (edge):like
              [(alice)] ------------ > [(bob)]
              -->
            </pre>

            <p>
              [= PREC-0 =] translates this property graph into an RDF graph
              isomorphic to the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:alice a pgo:Node .
              _:bob   a pgo:Node .
              _:edge  a pgo:Edge ;
                rdf:subject _:alice ;
                rdf:predicate [ rdfs:label "like" ] ;
                rdf:object  _: bob .
              -->
            </pre>

            <p>
              If we apply the following context with [= PREC-Context =], we will
              obtain the following RDF Data graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # Context
              prec:Edges prec:templatedBy prec:RDFReificaiton ;
                prec:subject <https://example.org/user> ;
                prec:predicate rdf:type ;
                prec:object <https://example.org/influencer> .
              -->
            </pre>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # RDF Data Graph
              _:edge a pgo:Edge ;
                <https://example.org/user> _:alice ;
                rdf:type [ rdfs:label "like" ] ;
                <https://example.org/influencer> _:bob .
              
              _alice a pgo:Node .
              _:bob  a pgo:Node .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4>Substitution terms defined in every context</h4>

          <p>
            The following substitution terms are defined for every context by
            [= PREC-Context =]:
            <ul>
              <li>`prec:subject`: Substitution term for `rdf:subject`.</li>
              <li>`prec:predicate`: Substitution term for `rdf:predicate`.</li>
              <li>`prec:object`: Substitution term for `rdf:object`.</li>
              <li>`prec:edgeIRI`: Substitution term for `pvar:edgeIRI`. Expected to be used in most [= prec:EdgeRule =]s.</li>
              <li>`prec:propertyIRI`: Substitution term for `pvar:propertyIRI`. Expected to be used in most [= prec:PropertyRule =].</li>
            </ul>
          </p>

          <p>
            `prec:subject`, `prec:predicate`, `prec:object` are defined to
            represent an edge as a fully fledge object. They let the user
            rename more accurate terms than the "RDF grounded terms". This is
            inspired by http://www.bobdc.com/blog/reification-is-a-red-herring/.
          </p>
        </section>
      </section>
    </section>

    <section class="informative">
      <h2>Test infrastructure</h2>

      <p>
      Used in `./test/prec/*.ttl` files, which are used for unit tests. These files
      are inputs for `./z_prec.js`.
      </p>
      
      
      <p>Each unit test contains:
        <ul>
        <li>where are the inputs by using `prec:testMetaData` as a subject</li>
        <li>the expected triples generated by PREC. Blank nodes are used as wildcards.</li>
        </ul>
      
      <h3>Unit test using external files</h3>
      
      <h4>http://bruy.at/prec#testMetaData</h4>
      
      Subject of triples that are inputs for `z_prec.js`. The triples with
      `prec:testMetaData` as a subject won't be tested against the actual output.
      
      <h4>http://bruy.at/prec#pgPath</h4>
      
      Relative path of the expected output file to the structure of the property
      graph.
      
      <h4>http://bruy.at/prec#pgSource</h4>
      
      An IRI that corresponds used to the method to obtain the Property Graph
      structure.
      
      Only https://neo4j.com/developer/neo4j-apoc/ is currently supported.
      It corresponds for the output of the `apoc.export.json.all` function in Neo4J.
      
      <h4>http://bruy.at/prec#contextPath</h4>
      
      Relative path of the expected output file to the used context.
      
      <h3>Self sufficient unit test </h3>
      
      <h4>http://bruy.at/prec#kind</h4>
      
      If the turtle fight contains `prec:testMetaData prec:kind "SmallExamples ."`,
      it means this turtle file contains multiple tests.
      
      
      <h4>http://bruy.at/prec#unitTest</h4>
      
      Type of a single unit test
      
      <h4>http://bruy.at/prec#context</h4>
      
      `prec:context` states what is the content of the context.
      
      `_:someTest prec:context _:context` means that the unit test `_:someTest` uses
      the content of the graph `_:context` as the context.
      
      
      <h4>http://bruy.at/prec#output</h4>
      
      `prec:output` states what is the expected output.
      
      `_:someTest prec:output _:output` means that the unit test `_:someTest` expects
      the content of the graph `_:output` as the output of PREC.
      
      
      <h4>http://bruy.at/prec#propertyGraph</h4>
      
      `prec:propertyGraph` states the content of the property graph as a string in the
      JSON APOC export format.

    </section>
  </body>
</html>
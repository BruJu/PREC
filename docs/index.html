<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PREC</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "unofficial",
        editors: [
            {
                name: "Julian Bruyat",
                url: "https://bruy.at",
                company: "LIRIS - INSA Lyon",
                companyURL: "https://liris.cnrs.fr",
                mailto: "julian.bruyat@insa-lyon.fr"
            }
        ],
        github: "https://github.com/BruJu/PREC/",
        xref: "web-platform",
        format: "markdown"
      };
    </script>
    
      <script>
        /* copied from JSON-LD specs */
        function updateExample(doc, content) {
          // perform transformations to make it render and prettier
          return _esc(reindent(unComment(doc, content)));
        }
    
        function _esc(s) {
          return s.replace(/&/g,'&amp;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;')
            .replace(/</g,'&lt;');
        }
    
        function reindent(text) {
          // TODO: use trimEnd when Edge supports it
          const lines = text.trimRight().split("\n");
          while (lines.length && !lines[0].trim()) {
            lines.shift();
          }
          const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
          const leastIndent = Math.min(...indents);
          return lines.map(s => s.slice(leastIndent)).join("\n");
        }
    
        function unComment(doc, content) {
          // perform transformations to make it render and prettier
          return content
            .replace(/<!--/, '')
            .replace(/-->/, '')
            .replace(/< !\s*-\s*-/g, '<!--')
            .replace(/-\s*- >/g, '-->')
            .replace(/-\s*-\s*&gt;/g, '--&gt;');
        }
      </script>
  </head>
  <body>
    <h2 id="subtitle">Property Graph - RDF Experimental Converter</h2>
    <section id="abstract">
      <p>PREC is a library designed to enable interoperability between RDF graphs
        and property graphs.</p>

      <p>This document mainly describes the PREC ontology: an ontology designed
        to describes the binding between the terms used in an RDF graph and the
        labels used in a property graph.</p>
    </section>
    <section>
      <h2>Introduction</h2>

      <p><a href="https://github.com/BruJu/PREC/">PREC</a> is composed of two modules:</p>
      <ul>
        <li><dfn>PREC-0</dfn>, a Property Graph to RDF graph converter</li>
        <li><dfn>PREC-Context</dfn>, an RDF Graph generated from PREC-0 to more readable graphs converter</li>
      </ul>
      
      <p>To define the transformations to apply, PREC-Context uses a <em>Context</em> provided
      by the user in <a href="https://w3c.github.io/rdf-star/cg-spec/editors_draft.html#turtle-star">Turtle-Star</a> format.
      </p>

      <aside class="warning" title="(Un)stability of the ontology">
        <p>This ontology is currently very tentative and is subject to change.</p>
      </aside>

      <section>
        <h3>Schema of the PREC-0 graphs</h3>
        <p>
          A partial SHACL Shapes Graph is available at
          <a href="https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl">
            https://github.com/BruJu/PREC/blob/master/docs/prec0shape.ttl
          </a>. This SHACL Shapes Graph should be conform on every PREC-0
          generated graph (graphs extracted by PREC without any context).
        </p>
      </section>

      <section>
        <h3>Use of a context</h3>

        <p>The context can be automatically applied during the convertion of the Property Graph to RDF:</p>
        <ul>
          <li>For example, for a Neo4j graph for which you have already extacted
            the content in Json format, use
            `node prec.js path_to_property_graph_content.json path_to_context.ttl`
          </li>
        </ul>
      
        <p>If you have already generated the PREC-0 graph, you can use the ApplyContext tool:</p>
        <ul>
          <li>`node tools.js ApplyContext path_to_prec0_graph.ttl path_to_context.ttl`</li>
        </ul>

      </section>

      <section>
        <h3>Example of a context</h3>

        <aside class="example">
          <p>
            In this section, we will present the ontology through a practical
            example. Considering a property graph with the following data
            (exposed in a format similar to a Cypher query):
          </p>

          <pre>
            ( haddock   :Person { name: "Haddock", firstName: "Archibald" } ),
            ( snowy     :Animal { name: "Snowy"  } ),
            ( the_serie :Serie  { name: "The Adventures of Tintin" } ),

            ( haddock ) -[ :appears { since: "The Crab with the Golden Claws"   } ]->( the_serie ),
            ( snowy   ) -[ :appears { since: "Tintin in the Land of the Soviets" }]->( the_serie ),
            ( haddock ) -[ :knows ]->( snowy )
          </pre>

          <p>
            PREC enables us to convert this Property Graph into an RDF graph.
            The graph generated without any context is very verbose, and will
            not be displayed here. Instead, we are going to write a context to
            produce a small and readable graph.
          </p>

          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
              @prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
              @prefix prec: <http://bruy.at/prec#> .
              @prefix pvar: <http://bruy.at/prec-trans#> .
              @prefix pgo:  <http://ii.uwb.edu.pl/pgo#> .

              # We want properties to be written in the RDF-graph as
              # [the node or relationship] [iri of the property] [the value]
              prec:Properties prec:modelAs prec:DirectTriples .

              # We want relationships to be written in the RDF-graph as
              # [the source] [the label] [the destination]
              # and use RDF-star for properties
              prec:Relationships prec:modelAs prec:RdfStarUnique .

              # == Properties

              # The name of a person is its family name
              [] a prec:PropertyRule ;
                prec:propertyName "name" ;
                prec:propertyIRI <http://schema.org/familyName> ;
                prec:nodeLabel "Person" .
              
              [] a prec:PropertyRule ;
                prec:propertyName "firstName" ;
                prec:propertyIRI <http://schema.org/givenName> .

              # Other names are names
              [] a prec:PropertyRule ;
                prec:propertyName "name" ;
                prec:propertyIRI <http://schema.org/name> .
              
              # We use an IRI from dbpedia for since
              # As writing rules for simples things is very long, we are
              # going to use a syntatctic sugar
              <http://dbpedia.org/property/debut> prec:IRIOfProperty "since" .

              # == Node labels
              <http://dbpedia.org/resource/Person> prec:IRIOfNodeLabel "Person" .
              <http://dbpedia.org/resource/Animal> prec:IRIOfNodeLabel "Animal" .
              <http://dbpedia.org/class/yago/Series108457976> prec:IRIOfNodeLabel "Serie" .

              # == Relationships
              <http://schema.org/knowsAbout> prec:IRIOfRelationship "knows" .
              <http://schema.org/knowsAbout> prec:IRIOfRelationship "knows" .

              # Map appears to schema:character. One problem of schema:character
              # is that is expect the serie as the subject and the character as
              # an object, but we can fix the order!
              [] a prec:RelationshipRule ;
                prec:relationshipLabel "appears" ;
                # We want the destination to be the source and the destination
                # to be the source so let's write our own model!
                prec:modelAs [
                  a prec:EdgeTransformation ;
                  prec:composedOf
                    # Assert the triple
                    <<    pvar:destination pvar:relationshipIRI pvar:source               >> ,
                    # Keep the provenance
                    << << pvar:destination pvar:relationshipIRI pvar:source >> a pgo:Edge >> ,
                    # Keep the properties
                    << << pvar:destination pvar:relationshipIRI pvar:source >> pvar:propertyKey pvar:propertyValue >> 
                ] ;
                # prec:relationshipIRI will actually replace pvar:relationship with schema:character
                prec:relationshipIRI <http://schema.org/character> .
            -->
          </pre>

          <p>
            The produce RDF-graph will be isomorphic to be following:
          </p>

          <pre data-transform="updateExample"
            data-content-type="text/turtle"
            class="nohighlight"
          >
            <!--
            # Note that Haddock have no http://schema.org/name
            _:haddock a pgo:Node, <http://dbpedia.org/resource/Person>;
                <http://schema.org/givenName> "Archibald";
                <http://schema.org/familyName> "Haddock".
            
            _:snowy a pgo:Node, <http://dbpedia.org/resource/Animal>;
                <http://schema.org/name> "Snowy".
            
            _:adventures_of_tintin a pgo:Node, <http://dbpedia.org/class/yago/Series108457976>;
                <http://schema.org/name> "The Adventures of Tintin";
                # The relationship have been properly inverted
                <http://schema.org/character> _:haddock, _:snowy.     

            _:haddock <http://schema.org/knowsAbout> _:snowy.
            <<_:haddock <http://schema.org/knowsAbout> _:snowy>> a pgo:Edge.
              
            # When did every character appear?
            <<_:adventures_of_tintin <http://schema.org/character> _:haddock>> a pgo:Edge;
                <http://dbpedia.org/property/debut> "The Crab with the Golden Claws".

            <<_:adventures_of_tintin <http://schema.org/character> _:snowy>> a pgo:Edge;
                <http://dbpedia.org/property/debut> "Tintin in the Land of the Soviets".
            -->
          </pre>

          <p>
            Note that in this example, while the produced output is easy to
            read and reuse existing ontologies, we are not conforming to the DBPedia
            usual schema, as in DBpedia, `<http://dbpedia.org/property/debut>`
            would be used with the character as the subject and the book (and
            not its name) as the object ; and in the current state of the
            ontology we can not do better. This is one of the weakness of
            the ontology: it can not conform to every schema.
          </p>
        </aside>
      </section>
    </section>

    <section>
      <h2>The PREC ontology</h2>

      <section>
        <h3>Types</h3>

        <section>
          <h4>http://bruy.at/prec#CreatedVocabulary</h4>
          
          <p>Type of IRIs that has been created by PREC and that
          should be mapped to an actual ontology.</p>

          <p>It only applies to labels and property names.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#Property</h4>

          <p>Type of property keys / labels.</p>
        </section>

        <section>
          <h4>http://bruy.at/prec#PropertyValue</h4>

          <p>Type of property values. Can be seed as the counterpart of
          <a href="http://ii.uwb.edu.pl/pgo#Property">pgo:Property</a> in the
          PREC modelization.</p>
        </section>
        
        <section>
          <h4><dfn data-lt="prec:hasMetaProperties">http://bruy.at/prec#hasMetaProperties</dfn></h4>

          <p>States to which (RDF) node the meta properties of a property are
            attached to.</p>

            <aside class="example">
              <p>Bob lives in Paris and is a tenant of his appartment.</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:bob :live_in [
                    rdf:type prec:PropertyValue ;
                    rdf:value "Paris" ;
                    prec:hasMetaProperties [
                        :status [ rdf:value "Tenant" ; rdf:type prec:PropertyValue ]
                    ]
                ] .
                
                :live_in a prec:Property .
                :status  a prec:Property .
                -->
              </pre>
            </aside>
        </section>
      </section>

      
      <section>
        <h3>Reserved IRIs</h4>

        <p>IRIs in the `prec` namespace are reserved for the ontology (obviously).</p>

        <p><a href="https://github.com/BruJu/PREC/">The default implementation</a>
          reserves for itself the IRIs prefixed with `_` and `__`.  Therefore,
          as they are reserved for implementation, using them in a context
          results in undefined behaviour.</p>
      </section>

      <section>
        <h3>General directives</h3>

        <section>
          <h4><dfn data-lt="prec:KeepProvenance">http://bruy.at/prec#KeepProvenance</dfn></h4>

          <p>By default, a triple is created for each node / relationship /
            property / property value between its IRI / blank node and the type.
          <br>If this flag is set to `false`, the triples in the form
            `ex:node1 a pgo:Node` are deleted from the output graph.</p>

          <aside class="example">
            <p>Keep the types (default behaviour).</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState true .
              -->
            </pre>

            <p>Remove the types.</p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              PREFIX prec: <http://bruy.at/prec#>
              prec:KeepProvenance prec:flagState false .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4>http://bruy.at/prec#flagState</h4>

          <p>Used as the predicate of [= prec:KeepProvenance =].</p>
        </section>
      </section>

      <section>
        <h3>Change the schema of the generated graph</h3>

        <p>[= PREC-0 =] generates an RDF Graph with a certain format. It is
          possible to change the way the properties and the relationships are
          modelled in the RDF graph.</p>

        <p>By default:</p>
        <ul>
          <li>Relationships are materialized using a standard RDF Reification</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:theEdge a pgo:Edge ;
              rdf:subject _:sourceNode ;
              rdf:predicate [ rdfs:label "TheLabel" ] ;
              rdf:object _:targetNode .
            -->
          </pre>
          <li>Properties are materialized like in the following example:</li>
          <pre data-transform="updateExample"
             data-content-type="text/turtle"
             class="nohighlight"
          >
            <!--
            _:eitherTheNodeOrTheEdge :propertyKey _:aBlankNode .
            _:aBlankNode rdf:value "The value of the property" .
            _:aBlankNode prec:hasMetaProperties _:aNodeWithTheMetaPropertiesIfAny .
            
            :propertyKey a prec:Property ; rdfs:label "The name of the property" .
            _:aBlankNode a prec:PropertyValue .
            -->
          </pre>
        </ul>

        <p>[= PREC-Context =] is able to change the format used to represent the
          properties and the relationships by using models.
          <br>In PREC, we call a *model* the format wanted by the user.</p>

          <section>
            <h4><dfn data-lt="prec:modelAs">http://bruy.at/prec#modelAs</dfn></h4>

            <p>Predicate used to state that the subject must be modelled in the
              format described in the object.</p>

              <aside class="example">
                <p>
                  A context that requires every relationship to be modelled
                  with the Singleton Property pattern.
                </p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  PREFIX prec: <http://bruy.at/prec#>
                  prec:Relationships prec:modelAs prec:SingletonProperty .
                  -->
                </pre>
              </aside>

          </section>

        <section>
          <h4>Relationship models</h4>

          <p>[= PREC-Context =] uses a special IRI for the set of every
            relationships and defines some base models that are implcitely
            defined in every context.</p>

          <p>Thanks to these IRIs and [= prec:modelAs =], it is possible to
            tranform the model used for every relationship from the standard
            RDF Reification to any model.
          </p>
          
          <section>
            <h5><dfn data-lt="prec:Relationships">http://bruy.at/prec#Relationships</dfn></h5>

            <p>[= prec:Relationships =] is the domain of every relationship. A
              model that is applied to this IRI will be applied to every
              relationship.</p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RDFReification">http://bruy.at/prec#RDFReification</dfn></h5>
            <p>
              `prec:Relationships prec:modelAs prec:RDFReification .`
              <br>Relationships must be modeled as a standard RDF Reification.
              This is the default behaviour.
            </p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarUnique">http://bruy.at/prec#RdfStarUnique</dfn></h5>
            <p>`prec:Relationships prec:modelAs prec:RdfStarUnique .`
              <br>Relationships are modeled as a triple that is added to th
               graph, and meta properties are added using RDF-star. This model
               will cause information loss if there are two edges with the same
               label between two nodes.</p>
          </section>
          <section>
            <h5><dfn data-lt="prec:RDFStarOccurrence">http://bruy.at/prec#RDFStarOccurrence</dfn></h5>
            <p>
              `prec:Relationships prec:modelAs prec:RDFStarOccurrence .`
              <br>Relationships are modeled as an RDF-star occurence: a blank
              node represents the occurrence and [= prec:occurrenceOf =] is used
              to link the node to the triple it is an occurence of.
            </p>

            <section>
              <h5><dfn data-lt="prec:occurrenceOf">http://bruy.at/prec#occurrenceOf</dfn></h5>

              <p><em>
                This IRI is used in the generated graphs and should not be used
                in contexts as a "keyword".
              </em></p>

              <p>
                Specifies for which triple the relationship is an occurrenceOf.
              </p>

              <aside class="example">
                <p>
                  Joe Biden "worked" for the White House from 2009 to 2017 as
                  the vice president and since 2021 as the president.
                </p>
                

                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  _:first  prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  _:second prec:occurrenceOf << :joe_biden :workingFor :white_house >>
                  
                  _:first  :from 2009; :to 2017 ; :role "Vice President" .
                  _:second :from 2021;            :role "President"      .
                  -->
                </pre>

                <p><em>Why do we need this?</em></p>
                
                <p>If we write</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >> :from 2009; :to 2017 ; :role "Vice President" .
                  << :joe_biden :workingFor :white_house >> :from 2021;            :role "President"      .
                  -->
                </pre>
                
                <p>it is equivalent to writing</p>
                <pre data-transform="updateExample"
                  data-content-type="text/turtle"
                  class="nohighlight"
                >
                  <!--
                  << :joe_biden :workingFor :white_house >>
                    :from 2009, 2021 ;
                    :to 2017 ;
                    :role "Vice President", "President" .
                  -->
                </pre>
                
                <p>
                  While we can deduce from the semantic of `:from`, `:to` and
                  years that Joe Biden worked from 2009 to 2017 then from 2021
                  for the White House, and while we know that we worked as the
                  Vice President and the President, we are unable to distinguish
                  when he was Vice President and when he was President.
                </p>
              </aside>
            </section>
          </section>
          <section>
            <h5><dfn data-lt="prec:SingletonProperty">http://bruy.at/prec#SingletonProperty</dfn></h5>
            <p>
              `prec:Relationships prec:modelAs prec:SingletonProperty .`
              <br>Relationships must be modeled using singleton properties.
            </p>
          </section>
        </section>

        <section>
          <h4>Property models</h4>

          <p>The model used for properties can also be redefined.</p>

          <section>
            <h5><dfn data-lt="prec:Properties">http://bruy.at/prec#Properties</dfn></h5>

            <p>
              The domain of every properties. A triple that has
              [= prec:Properties =] as a subject is equivalent to three triples,
              one with [= prec:NodeProperties =] as the subject, another with
              [= prec:RelationshipProperties =] as the subject and another
              with [= prec:MetaProperties =] as the subject.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:NodeProperties">http://bruy.at/prec#NodeProperties</dfn></h5>

            <p>The domain of every node properties. The properties on
              relationships won't be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:RelationshipProperties">http://bruy.at/prec#RelationshipProperties</dfn></h5>

            <p>The domain of every relationship properties. The properties on
              nodes won't be affected by directives applied to this.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:MetaProperties">http://bruy.at/prec#MetaProperties</dfn></h5>

            <p>
              The domain of every meta properties (properties on properties).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:Prec0Property">http://bruy.at/prec#Prec0Property</dfn></h5>

            <p>
              Properties are modeled in the format presented in the
              [= prec:hasMetaProperties =] example. This is the default
              behaviour.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:CombinedBlankNodes">http://bruy.at/prec#CombinedBlankNodes</dfn></h5>

            <p>
              Properties are modeled in the same format as
              [= prec:Prec0Property =], but the `propertyValue` and the
              `metaProperty` nodes are merged.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:DirectTriples">http://bruy.at/prec#DirectTriples</dfn></h5>

            <p>
              Properties are modeled without any blank node
              (`:node :propertyKey :thePropertyValueLiteral`), and the meta
              properties are represented by using RDF-star.
            </p>
          </section>
        </section>

        <section>
          <h4>Writting your own models</h4>

          <p>
            So far, this document described how to use predefined models. It is
            also possible to write you own models.
          </p>

          <p>
            Models uses the `pvar` namespace (http://bruy.at/prec-trans#) as
            variable. pvar can be seen as a way to write `?` in a Turtle file
            without actually using a real variable.
          </p>

          <aside class="note">
            <p>
              Every built-in model is actually defined in a turtle file that
              is loaded and included to every context you write.
            </p>
          </aside>

          <section>
            <h5><dfn data-lt="prec:composedOf">http://bruy.at/prec#composedOf</dfn></h5>

            <p>
              Used to state the list of RDF triples that composes the model.
              When the model is applied, every triple used in the default PREC0
              model will be replaced with the triples that composes the model.
            </p>

            <p>
              Models and the variables it contains can be seen as a template.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:EdgeTransformation">http://bruy.at/prec#EdgeTransformation</dfn></h5>

            <aside class="warning">
              TODO: EdgeTransformation should be named RelationshipModel
            </aside>

            <p>The type of models that can be used for relationships.</p>

            <p>`EdgeTransformation`s use the following variable:</p>
            <ul>
              <li>`pvar:self`: The RDF node that was created to identify the relationship.</li>
              <li>`pvar:source`: The RDF node that represents the PG source node of the relationship.</li>
              <li>`pvar:destination`: The RDF node that represents the PG destination relationship.</li>
              <li>`pvar:relationshipIRI`: The RDF node that represents the label of the edge.</li>
              <li>`pvar:propertyKey`: matchs every other predicates. Supposed to represent each property key.</li>
              <li>`pvar:propertyValue`: matchs every other objects. Supposed to represent each property value.</li>
            </ul>

            <p>
              We are going to show how a user can define its own model

            <aside class="example">
              <p>An [= prec:EdgeTransformation =] that is the identity / the standard RDF Reification</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RDFReification a prec:EdgeTransformation ;
                  prec:composedOf
                    << pvar:self a pgo:Edge >> ,
                    << pvar:self rdf:subject      pvar:source          >> ,
                    << pvar:self rdf:predicate    pvar:relationshipIRI >> ,
                    << pvar:self rdf:object       pvar:destination     >> ,
                    << pvar:self pvar:propertyKey pvar:propertyValue   >>
                .
                -->
              </pre>

              <p>
                Note that `prec:RDFReification` is the pattern that is matched
                against, which means modelling a relationship as a
                `prec:RDFReification` will result in the samegraph.
              </p>
            </aside>

            <aside class="example">
              <p>
                [= prec:RDFStarUnique =] is a model that assumes that every
                edges between the same two nodes have a different label.
              </p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:RdfStarUnique a prec:EdgeTransformation ;
                  prec:composedOf
                    <<    pvar:source pvar:relationshipIRI pvar:destination               >> , # (a)
                    << << pvar:source pvar:relationshipIRI pvar:destination >> a pgo:Edge >> , # (b)
                    << << pvar:source pvar:relationshipIRI pvar:destination >> pvar:propertyKey pvar:propertyValue >>  # (c)
                .
                -->
              </pre>

              <p>If we suppose we have the following RDF Graph:</p>
              
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:edge1 a pgo:Edge ;
                  rdf:subject _:src ;
                  rdf:predicate _:label ;
                  rdf:object _:dest ;
                  _:propPlace _:propValuePlace ;
                  _:propTime  _:propValueTime .
                -->
              </pre>

              <p>The variables will match as follow:</p>

              <table>
                <tr><th>Variable name</th>             <th>Value</th>               </tr>
                <tr><td> `pvar:self`              </td><td> `_:edge1`          </td></tr>
                <tr><td> `pvar:source`            </td><td> `_:src`            </td></tr>
                <tr><td> `pvar:destination`       </td><td> `_:dest`           </td></tr>
                <tr><td> `pvar:relationshipIRI`   </td><td> `_:label`          </td></tr>
                <tr><td> `pvar:propertyKey`   (1) </td><td> `_:propPlace`      </td></tr>
                <tr><td> `pvar:propertyValue` (2) </td><td> `_:propValuePlace` </td></tr>
                <tr><td> `pvar:propertyKey`   (2) </td><td> `_:propTime`       </td></tr>
                <tr><td> `pvar:propertyValue` (2) </td><td> `_:propValueTime`  </td></tr>
              </table>
              
              <p>And the produced graph will be the following:</p>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                _:src _:label _:dest .                  # From (a)
                << _:src _:label _:dest >> a pgo:Edge . # From (b)
                << _:src _:label _:dest >> _:propPlace _:propValuePlace . # From (c) using (1) bindings
                << _:src _:label _:dest >> _:propTime  _:propValueTime  . # From (c) using (2) bindings
                -->
              </pre>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:PropertyTransformation">http://bruy.at/prec#PropertyTransformation</dfn></h5>

            <p>The type of models that can be used for properties.</p>
            
            <aside class="warning">
              <p>TODO: PropertyTransformation should be named PropertyModel</p>
            </aside>

            <p>`prec:PropertyTransformation`s use the following variables:</p>
            <ul>
              <li>`pvar:entity`: The RDF node that was created to identify the edge of the node.</li>
              <li>`pvar:propertyKey`: The node that represents the edge label.</li>
              <li>`pvar:property`: The blank node that represents the property.</li>
              <li>`pvar:propertyValue`: The literal that contains the property value.</li>
              <li>`pvar:metaPropertyNode`: The blank node that contains every meta property, as described in [= prec:hasMetaProperties =]</li>
              <li>`pvar:metaPropertyKey`: The predicate of a meta property triple.</li>
              <li>`pvar:metaPropertyValue`: The object of a meta property triple.</li>
            </ul>

            <p>
              The substitution mecanism is the same as described in the
              [= prec:EdgeTransformation =] section.
            </p>

            <p>Some restrictions exists on property models:
              <ul>
                <li>
                  `pvar:entity` can only appear in the "subject-star" position.
                  The `subject-star` position is defined recursively as either
                  the subject of the quad if it is not a nested quad, or the
                  "subject-star" of the quad in the subject position. In other
                  words, when the Triple-star is written in the N-Triples-star
                  format, it is the first non RDF-star term that appears for
                  this triple.
                </li>
                <li>
                  Every embedded triple must be asserted by the model.
                </li>
                <li>
                  `pvar:metaPropertyKey` and `pvar:metaPropertyValue`, if they
                  appear, must appear both at the same time, and as repectively
                  the predicate and the object.
                </li>
              </ul>
            </p>
            <p>
              These restriction exists to make between combinaisons a
              relationship model and different property models possible.
            </p>
          </section>
        </section>

      <section>
        <h3>Rules</h3>

        <p>
          Rules are the main way to modify a [= PREC-0 =] RDF graph. They let
          the user modify specific elements of the graphs by:
          <ul>
            <li>filtering some of the relationships or properties</li>
            <li>applying a specific model to these entities</li>
          </ul>
        </p>

        <p>
          As one can expect, there are two different kind of rules : rules for
          relationships ([= prec:RelationshipRule =]) and rules for properties
          ([= prec:PropertyRule =]).
        </p>

        <section>
          <h4>Relationship rules</h4>

          <p>
            Relationship rules aim to modify the way the property graph
            relationships are materialized in the RDF Graph.
          </p>

          <aside class="example">
            <p>
              A rule that only applies to relationships with the label "Like"
              and for which both the source and the destination node have the
              label "Person". This rule will materialize these relationship
              as a standard RDF Triple, with `ex:like` as the predicate
              (for example `:alice ex:like :bob` will be produced).
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [] a prec:RelationshipRule ;
                # - Filtering
                # Like must be the relationship label
                prec:relationshipLabel "Like" ;
                # The source node must have the label Person
                prec:sourceLabel      "Person" ;
                # The destination node must have the label Person
                prec:destinationLabel "Person" ;
                # - Transformation
                # Replace the generated IRI for the relationship label with ex:like
                prec:relationshipIRI ex:like ;
                # Modelize this relationship by using the prec:RDFStarUnique
                # model instead of a standard RDF Reification
                prec:modelAs prec:RDFStarUnique .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:RelationshipRule">http://bruy.at/prec#RelationshipRule</dfn></h5>

            <p>
              The type of relationship rules. The [= PREC-Context =] engine
              currently requires the relationship rules to be properly typed to
              be able to discover them.
            </p>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:relationshipLabel">http://bruy.at/prec#relationshipLabel</dfn></h5>

            <p>
              States that the relationship must have the given label to match
              the rule. The value must be a literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:relationshipIRI">http://bruy.at/prec#relationshipIRI</dfn></h5>

            <p>
              States that the generated node for the relationship must be
              replaced with the given IRI.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:sourceLabel">http://bruy.at/prec#sourceLabel</dfn></h5>

            <p>
              States that the relationship source node must have the given
              label. The value must be a literal.
            </p>

            
            <aside class="example">
              <p>
                Let us consider we have the following property graph, with
                three nodes: one of type Person, one of type Cat and one of type
                Food. The Person likes the Cat and the Cat likes the Food.
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                                 (a)                     (b)
                [ :Person ] --- :Like -- > [ :Cat ] --- :Like -- > [ :Food ]
                -->
              </pre>

              <p>
                We can write the following relationship rule:
              </p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                prec:Relationships prec:modelAs prec:RDFStarUnique .

                # Matches (a)
                :firstRule a prec:RelationshipRule ;
                  prec:relationshipLabel "Like" ;
                  prec:sourceLabel "Person" ;
                  prec:relationshipIRI ex:likes .
                
                # Matches (b)
                :secondRule a prec:RelationshipRule ;
                  prec:relationshipLabel "Like" ;
                  prec:sourceLabel "Cat" ;
                  prec:relationshipIRI ex:eats .
                -->
              </pre>

              <p>The output graph would be the following:</p>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                # Matches :firstRule, also applies the new default model
                _:person ex:likes _:cat  {| a pgo:Edge |} .
                # Matches :secondRule, also applies the new default model
                _:cat    ex:eats  _:food {| a pgo:Edge |} .

                _:person a pgo:Node, [ rdfs:label "Person" ].
                _:cat    a pgo:Node, [ rdfs:label "Cat"    ].
                _:food   a pgo:Node, [ rdfs:label "Food"   ].
                -->
              </pre>
            </aside>
          </section>
          
          <section>
            <h5><dfn data-lt="prec:destinationLabel">http://bruy.at/prec#destinationLabel</dfn></h5>

            <p>
              Same as [= prec:sourceLabel =], but for the destination node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfRelationship">http://bruy.at/prec#IRIOfRelationship</dfn></h5>

            <p>
              Shortcut to define a relationship rule that matches relationships
              with a specific label and map the relationship label to a specific
              IRI.
            </p>

            <p>The two following contexts are equivalents:

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :iri prec:IRIOfRelationship "Label" .
                -->
              </pre>
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:RelationshipRule ;
                  prec:relationshipLabel "Label" ;
                  prec:relationshipIRI :iri .
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifiying a model</h5>

            <p>
              Like [= prec:Relationships =], it is possible to define a target
              model for relationship rules by using the [= prec:modelAs =]
              predicate. It is also possible to apply any
              [= prec:SubstitutionTerm =]s, and not only
              [= prec:relationshipIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4>Property rules</h4>

          <p>
            A property rule is a rule that can be applied to a property. In a
            similar fashion as relationship rules, a property rule targets some
            properties, and can modify how they are materialized in the graph.
          </p>

          <aside class="example">
            <p>
              Let us consider we have the following property graph, with
              three nodes: one of type Person, one of type Cat and one of type
              Food. The Person likes the Cat and the Cat likes the Food.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person { name: "Macron", givenName: "Emmanuel" }]
                  |
                [ :Owns { since: 2017 } ]
                  |
                 \|/
              [ :Animal { name: "Nemo" }]
              -->
            </pre>

            <p>
              We can use the following context:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:Properties    prec:modelAs prec:DirectTriples .

              # A rule for the name property of nodes of type Person
              :humanNameRule a prec:PropertyRule ;
                prec:propertyName "name" ;
                prec:propertyIRI <http://schema.org/familyName> ;
                prec:nodeLabel "Person" .
              
              # A rule for the name property of other things
              :otherNameRule a prec:PropertyRule ;
                prec:propertyName "name" ;
                prec:propertyIRI <http://schema.org/name> .
              
              # Other rules
              :givenNameRule a prec:PropertyRule ;
                prec:propertyName "givenName" ;
                prec:propertyIRI <http://schema.org/givenName> .
              
              # The following could have been written
              # [] a prec:PropertyRule ; prec:propertyName "since" ; prec:propertyIRI :since
              :since prec:IRIOfProperty "since" .
              -->
            </pre>

            <p>The resulting graph would be the (isomorphic to) the following:</p>


            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:macron a pgo:Node, [ rdfs:label "Person" ] .
              _:nemo   a pgo:Node, [ rdfs:label "Animal" ] .

              # Matches :humanNameRule
              _:macron <http://schema.org/familyName> "Macron" .
              # Matches :givenNameRule
              _:macron <http://schema.org/givenName>  "Emmanuel" .

              # Matches :otherNameRule
              _:nemo <http://schema.org/name> "Nemo" .

              # The relationship
              _:macronownsnemo a pgo:Edge ;
                rdf:subject   _:macron ;
                rdf:object    _:nemo ;
                rdf:predicate [ rdfs:label "Owns" ] .
              # The property of the relationship matches the prec:IRIOfProperty rule
              _:macronownsnemo :since 2017 .
              -->
            </pre>
          </aside>

          <section>
            <h5><dfn data-lt="prec:PropertyRule">http://bruy.at/prec#PropertyRule</dfn></h5>

            <p>
              The type of property rules. The [= PREC-Context =] engine
              currently requires the property rules to be propertly typed to
              be able to discover them.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyName">http://bruy.at/prec#propertyName</dfn></h5>

            <p>
              The name / the key of the matched properties. The value must be a
              literal.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:propertyIRI">http://bruy.at/prec#propertyIRI</dfn></h5>

            <p>
              States the IRI to use for this property name. Its value will be
              used instead of the generated node.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:nodeLabel">http://bruy.at/prec#nodeLabel</dfn></h5>

            <p>
              States the label that the node must have for the rule to apply. If
              there are several values for [= prec:nodeLabel =], the node must
              have every labels. This predicate is incompatible with
              [= prec:relationshipLabel (used in a property rule) =]. The value
              must be either a literal or [= prec:any =]. If the value is
              [= prec:any =], then any node, and no relationship, can be matched
              (even the one without labels).
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:relationshipLabel (used in a property rule)">http://bruy.at/prec#relationshipLabel (in a property Rule)</dfn></h5>

            <p>
              States the label that the relationship must have for the rule to
              apply. The value must be either a literal or [= prec:any =]. If
              the value is [= prec:any =], then any relationship, and no node
              can be matched. Because relationship can only have one label, if
              there are several `prec:relationshipLabel` clauses, the rule won't
              be able to be matched with any relationship.
            </p>
          </section>

          <section>
            <h5><dfn data-lt="prec:any">http://bruy.at/prec#any</dfn></h5>

            <p>
              Special value for [= prec:nodeLabel =] and
              [= prec:relationshipLabel (used in a property rule) =] that can be
              states that the rule can be matched with any node or relationship.
            </p>

            <aside class="warning">
              <p>
                As the semantic for [= prec:any =] used on a
                [= prec:nodeLabel =] is strange (it can match a node that does
                not have any label), [= prec:any =] may be deleted in a future
                version of the ontology.
              </p>
            </aside>
          </section>

          <section>
            <h5><dfn data-lt="prec:IRIOfProperty">http://bruy.at/prec#IRIOfProperty</dfn></h5>

            <p>
              Enables to declare simple property rules with only one triple,
              instead of three.
            </p>

            <p>The two following rules are equivalent:
              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                :someIRI prec:IRIOfProperty "APropertyName" .
                -->
              </pre>

              <pre data-transform="updateExample"
                 data-content-type="text/turtle"
                 class="nohighlight"
              >
                <!--
                [] a prec:PropertyRule ;
                  prec:propertyName "APropertyName" ;
                  prec:propertyIRI :someIRI
                -->
              </pre>
            </p>
          </section>

          <section>
            <h5>Specifying a model</h5>

            <p>
              Like [= prec:Properties =], [= prec:NodeProperties =] and
              [= prec:RelationshipProperties =], it is possible to specify a
              model for a specific property rule thanks to [= prec:modelAs =]
              and to use [= prec:SubstitutionTerms =] other than
              [= prec:propertyIRI =].
            </p>
          </section>
        </section>

        <section>
          <h4><dfn data-lt="prec:priority">http://bruy.at/prec#priority</dfn></h4>

          <p>
            By default, [= PREC-Context =] tries to apply rules from the more
            specific to the less specific. While the order of the rules is
            deterministic, the user may prefer to use another.
            [= prec:priority =] enables to change the order of the rules.
          </p>

          <aside class="example">
            <p>
              With this context, thanks to the priority, if a relationship
              has a source label that is both an animal and a person, the
              `:personLike` rule is guaranteed to be applied.
            </p>
            <pre data-transform="updateExample"
               data-content-type="text/turtle"
               class="nohighlight"
            >
              <!--
              :personLike a prec:RelationshipRule ;
                prec:relationshipLabel "Like" ;
                prec:sourceLabel "Person" ;
                prec:priority 2 ;
                prec:relationshipIRI ex:likes .
                
              :catLike a prec:RelationshipRule ;
                prec:relationshipLabel "Like" ;
                prec:sourceLabel "Animal" ;
                prec:priority 1 ;
                prec:relationshipIRI ex:kind_of_accepts .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4><dfn data-lt="prec:IRIOfNodeLabel">http://bruy.at/prec#IRIOfNodeLabel</dfn></h4>

          <p><em>Usage</em>: ` :IRIToMapTo prec:IRIOfNodeLabel "Label" .`</p>

          <p>
            The last kind of nodes that can be remapped are node labels. Unlike
            property labels, the only way to map an IRI to them is to use
            the [= prec:IRIOfNodeLabel =], in a similar fashion as
            [= prec:IRIOfRelationship =].
          </p>

          <p>
            [= prec:IRIOfNodeLabel =] states that the node labels equals to
            its object (`"Label`) should be mapped to the IRI stated as the
            subject of the triple (`:IRIToMapTo`), instead of generating /
            keeping a generated a blank node or IRI.
          </p>

          <aside class="example">
            <p>Let us consider the following property graph with two nodes, one
              with the label Person and one with the label Animal:
            </p>
            
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person ]    [ :Animal ]
              -->
            </pre>

            <p>
              [= PREC-0 =] will convert this graph into the following RDF graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node, [ rdfs:label "Person" ] .
              _:node2 a pgo:Node, [ rdfs:label "Animal" ] .
              -->
            </pre>

            <p>Let us consider the following context:</p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              schema:Person prec:IRIOfNodeLabel "Person" .
              schema:Animal prec:IRIOfNodeLabel "Animal" .
              -->
            </pre>

            <p>
              [= PREC-Context =] will transform the [= PREC-0 =] graph into
              the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node1 a pgo:Node, schema:Person .
              _:node2 a pgo:Node, schema:Animal .
              -->
            </pre>
          </aside>
        </section>

        
        <section>
          <h4><dfn data-lt="prec:mapBlankNodesToPrefix">http://bruy.at/prec#mapBlankNodesToPrefix</dfn></h4>
          
          <p>
            The graph generated by [= PREC-0 =] uses blank nodes for everything
            that is not a label or a value. The user may prefer to have IRIs
            generated for the different part of the vocabulary. For example,
            instead of generating a blank node for the label "Person", the user
            may prefer to get `http://example.org/Person`.
          </p>

          <p>
            [= prec:mapBlankNodesToPrefix =] enables to map
            <ul>
              <li>every node label if the subject is pgo:Node</li>
              <li>every relationship label if the subject is pgo:Edge</li>
              <li>every property name if the subject is [= prec:Property =]</li>
            </ul>
            to IRis that starts with the prefix specfied in object position.
          </p>

          <aside class="warning">
            <p>
              The author of the ontology recognizes that using pgo:Node
              and pgo:Edge for the group of every node labels and every
              relationship labels was a terrible idea. The expected subjects
              of [= prec:mapBlankNodesToPrefix =] are subject to change.
            </p>
          </aside>

          <aside class="example">
            <p>
              Given the following Property Graph
            </p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              [ :Person :Animal ]
              -->
            </pre>
            <p>And the following context:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              pgo:Node prec:mapBlankNodesToPrefix <http://example.org#>.
              -->
            </pre>
            <p>The generated graph will be of the form:</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:node a pgo:Node ,
                       http://example.org#something1 ,
                       http://example.org#something2 .
              
              # The suffix can be anything
              http://example.org#something1 rdfs:label "Person" .
              http://example.org#something2 rdfs:label "Animal" .
              -->
            </pre>
          </aside>
        </section>

      </section>
      
      <section>
        <h3>Substitutions</h3>

        <p>
          Most rules actually use alterations of models. For example, in
          [= prec:RelationshipRule =]s, most of the time the
          `pvar:relationshipIRI` variable will be replaced by an IRI picked by
          the user thanks to [= prec:relationshipIRI =].
        </p>

        <p>
          The reason why [= prec:relationshipIRI =] can modify the model is
          because it is defined as a [= prec:SubstitutionTerm =] for
          `pvar:relationshipIRI`: when used in a rule,
          [= prec:relationshipIRI =] will look for every `pvar:relationshipIRI`
          occurrence, and replace it with something else.
        </p>

        <section>
          <h4><dfn data-lt="prec:SubstitutionTerm">http://bruy.at/prec#SubstitutionTerm</dfn></h4>

          <p>
            The type of substitution terms. To be effective, a
            [= prec:SubstitutionTerm =] should have a value for
            [= prec:substitutionTarget =].
          </p>
        </section>

        <section>
          <h4><dfn data-lt="prec:substitutionTarget">http://bruy.at/prec#substitutionTarget</dfn></h4>

          <p>
            States the term that is looked for in the model on which the
            substitution term applies.
          </p>
          
          <aside class="example">
            <p>`prec:subject` is a substitution term for `rdf:subject`.</p>
            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              prec:subject a prec:SubstitutionTerm ;
                prec:substitutionTarget rdf:subject.
              -->
            </pre>

            <p>
              When `prec:subject` is used on a rule, it will replace
              `rdf:subject` with something else. Similar directives exist
              for `prec:predicate` and `prec:object`.
            </p>
          </aside>

          <aside class="example">
            <p>
              Let us consider we have the following property graph. Values
              inside parenthesis are not actual values, and are solely for
              clarity. In this graph, we have two nodes, and a relationship
              from one to another with the label `like`.
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
                        (edge):like
              [(alice)] ------------ > [(bob)]
              -->
            </pre>

            <p>
              [= PREC-0 =] translates this property graph into an RDF graph
              isomorphic to the following:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              _:alice a pgo:Node .
              _:bob   a pgo:Node .
              _:edge  a pgo:Edge ;
                rdf:subject _:alice ;
                rdf:predicate [ rdfs:label "like" ] ;
                rdf:object  _: bob .
              -->
            </pre>

            <p>
              If we apply the following context with [= PREC-Context =], we will
              obtain the following RDF Data graph:
            </p>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # Context
              prec:Relationships prec:modelAs prec:RDFReificaiton ;
                prec:subject <https://example.org/user> ;
                prec:predicate rdf:type ;
                prec:object <https://example.org/influencer> .
              -->
            </pre>

            <pre data-transform="updateExample"
              data-content-type="text/turtle"
              class="nohighlight"
            >
              <!--
              # RDF Data Graph
              _:edge a pgo:Edge ;
                <https://example.org/user> _:alice ;
                rdf:type [ rdfs:label "like" ] ;
                <https://example.org/influencer> _:bob .
              
              _alice a pgo:Node .
              _:bob  a pgo:Node .
              -->
            </pre>
          </aside>
        </section>

        <section>
          <h4>Substitution terms defined in every context</h4>

          <p>
            The following substitution terms are defined for every context by
            [= PREC-Context =]:
            <ul>
              <li>`prec:subject`: Substitution term for `rdf:subject`.</li>
              <li>`prec:predicate`: Substitution term for `rdf:predicate`.</li>
              <li>`prec:object`: Substitution term for `rdf:object`.</li>
              <li>`prec:relationshipIRI`: Substitution term for `pvar:relationshipIRI`. Expected to be used in most [= prec:RelationshipRule =]s.</li>
              <li>`prec:propertyIRI`: Substitution term for `pvar:propertyIRI`. Expected to be used in most [= prec:PropertyRule =].</li>
            </ul>
          </p>

          <p>
            `prec:subject`, `prec:predicate`, `prec:object` are defined to
            model a relationship as a fully fledge object. They let the user
            rename more accurate terms than the "RDF grounded terms". This is
            inspired by http://www.bobdc.com/blog/reification-is-a-red-herring/.
          </p>
        </section>
      </section>
    </section>

    <section class="informative">
      <h2>Test infrastructure</h2>

      <p>
      Used in `./test/prec/*.ttl` files, which are used for unit tests. These files
      are inputs for `./z_prec.js`.
      </p>
      
      
      <p>Each unit test contains:
        <ul>
        <li>where are the inputs by using `prec:testMetaData` as a subject</li>
        <li>the expected triples generated by PREC. Blank nodes are used as wildcards.</li>
        </ul>
      
      <h3>Unit test using external files</h3>
      
      <h4>http://bruy.at/prec#testMetaData</h4>
      
      Subject of triples that are inputs for `z_prec.js`. The triples with
      `prec:testMetaData` as a subject won't be tested against the actual output.
      
      <h4>http://bruy.at/prec#pgPath</h4>
      
      Relative path of the expected output file to the structure of the property
      graph.
      
      <h4>http://bruy.at/prec#pgSource</h4>
      
      An IRI that corresponds used to the method to obtain the Property Graph
      structure.
      
      Only https://neo4j.com/developer/neo4j-apoc/ is currently supported.
      It corresponds for the output of the `apoc.export.json.all` function in Neo4J.
      
      <h4>http://bruy.at/prec#contextPath</h4>
      
      Relative path of the expected output file to the used context.
      
      <h3>Self sufficient unit test </h3>
      
      <h4>http://bruy.at/prec#kind</h4>
      
      If the turtle fight contains `prec:testMetaData prec:kind "SmallExamples ."`,
      it means this turtle file contains multiple tests.
      
      
      <h4>http://bruy.at/prec#unitTest</h4>
      
      Type of a single unit test
      
      <h4>http://bruy.at/prec#context</h4>
      
      `prec:context` states what is the content of the context.
      
      `_:someTest prec:context _:context` means that the unit test `_:someTest` uses
      the content of the graph `_:context` as the context.
      
      
      <h4>http://bruy.at/prec#output</h4>
      
      `prec:output` states what is the expected output.
      
      `_:someTest prec:output _:output` means that the unit test `_:someTest` expects
      the content of the graph `_:output` as the output of PREC.
      
      
      <h4>http://bruy.at/prec#propertyGraph</h4>
      
      `prec:propertyGraph` states the content of the property graph as a string in the
      JSON APOC export format.

    </section>
  </body>
</html>